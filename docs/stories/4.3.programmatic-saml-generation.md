# Story 4.3: Programmatic SAML Generation

## Status
Done

## Story

**As a** developer,
**I want** to generate SAML assertions programmatically,
**so that** I don't need pre-defined templates for standard scenarios.

## Acceptance Criteria

1. SAML generator creates SAML 2.0 assertion from parameters
2. Required parameters: subject, issuer, audience
3. Optional parameters: attributes, conditions, validity duration
4. Generated assertion follows SAML 2.0 specification structure
5. Assertion includes AuthnStatement with timestamp
6. Configurable assertion validity period (default 5 minutes)
7. Support for custom attribute statements
8. Generated SAML properly formatted and canonicalized for signing
9. Integration with certificate management for issuer identity
10. Unit tests verify SAML structure, validity periods, attribute handling

## Tasks / Subtasks

- [ ] Review existing SAML infrastructure from Stories 4.1 and 4.2 (AC: 1, 9)
  - [ ] Review src/ihe_test_util/saml/certificate_manager.py (Story 4.1 - complete)
  - [ ] Review src/ihe_test_util/saml/template_loader.py (Story 4.2 - complete)
  - [ ] Review src/ihe_test_util/models/saml.py (SAMLAssertion dataclass)
  - [ ] Review examples/signxml_saml_example.py (spike 1.2 - SAML generation patterns)
  - [ ] Understand timestamp generation and assertion ID patterns from template_loader
  - [ ] Identify reusable utility functions for timestamps, IDs, and canonicalization

- [ ] Create programmatic SAML generator module (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Create src/ihe_test_util/saml/programmatic_generator.py module
  - [ ] Function: generate_saml_assertion(subject: str, issuer: str, audience: str, **kwargs) -> SAMLAssertion
  - [ ] Required parameters validation: subject, issuer, audience must be non-empty strings
  - [ ] Optional parameters: attributes (dict), validity_minutes (int, default 5), conditions (dict)
  - [ ] Generate unique assertion ID using uuid.uuid4() with underscore prefix (reuse pattern from template_loader)
  - [ ] Generate timestamps: issue_instant, not_before, not_on_or_after in ISO 8601 format with Z suffix
  - [ ] Build SAML 2.0 Assertion structure using lxml.etree
  - [ ] Include required SAML 2.0 namespace: urn:oasis:names:tc:SAML:2.0:assertion
  - [ ] Add proper type hints and Google-style docstrings
  - [ ] Use logging module for all messages (RULE 1)
  - [ ] Raise exceptions with actionable context (RULE 5)

- [ ] Implement SAML 2.0 Assertion structure builder (AC: 4, 5)
  - [ ] Function: _build_assertion_element(assertion_id: str, issue_instant: str, issuer: str) -> etree.Element
  - [ ] Create <saml:Assertion> root element with required attributes: ID, Version="2.0", IssueInstant
  - [ ] Add SAML 2.0 namespace declaration
  - [ ] Add <saml:Issuer> element with issuer value
  - [ ] Add <saml:Subject> element with <saml:NameID> containing subject value
  - [ ] Add SubjectConfirmation with Method="urn:oasis:names:tc:SAML:2.0:cm:bearer"
  - [ ] Add SubjectConfirmationData with NotOnOrAfter timestamp
  - [ ] Ensure all required elements per SAML 2.0 spec

- [ ] Implement Conditions element builder (AC: 3, 6)
  - [ ] Function: _add_conditions_element(assertion: etree.Element, not_before: str, not_on_or_after: str, audience: str) -> None
  - [ ] Create <saml:Conditions> element with NotBefore and NotOnOrAfter attributes
  - [ ] Add <saml:AudienceRestriction> sub-element
  - [ ] Add <saml:Audience> element with audience value
  - [ ] Support optional additional conditions from kwargs if provided
  - [ ] Default validity period: 5 minutes from current time

- [ ] Implement AuthnStatement builder (AC: 5)
  - [ ] Function: _add_authn_statement(assertion: etree.Element, authn_instant: str, assertion_id: str) -> None
  - [ ] Create <saml:AuthnStatement> element with AuthnInstant attribute
  - [ ] Add SessionIndex attribute (use assertion_id)
  - [ ] Create <saml:AuthnContext> sub-element
  - [ ] Add <saml:AuthnContextClassRef> with value: urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
  - [ ] Follow SAML 2.0 specification for AuthnStatement structure

- [ ] Implement custom attribute statement builder (AC: 7)
  - [ ] Function: _add_attribute_statement(assertion: etree.Element, attributes: dict[str, str | list[str]]) -> None
  - [ ] Create <saml:AttributeStatement> element
  - [ ] For each attribute in attributes dict:
    - [ ] Create <saml:Attribute> element with Name attribute
    - [ ] Add <saml:AttributeValue> child element with attribute value
  - [ ] Support multiple attributes (e.g., username, role, organization, etc.)
  - [ ] Handle empty attributes dict gracefully (skip AttributeStatement if no attributes)
  - [ ] Implement multi-valued attribute support:
    - [ ] Detect if attribute value is a list
    - [ ] For list values, create multiple <saml:AttributeValue> elements under same <saml:Attribute>
    - [ ] For string values, create single <saml:AttributeValue> element
    - [ ] Example: {"roles": ["physician", "admin"]} → two AttributeValue elements under one Attribute

- [ ] Implement XML canonicalization for signing readiness (AC: 8)
  - [ ] Function: _canonicalize_assertion(assertion: etree.Element) -> str
  - [ ] Use lxml.etree.tostring() with method='c14n' for canonicalization
  - [ ] Return canonicalized XML string ready for signing
  - [ ] Ensure proper C14N format per W3C specification
  - [ ] Preserve XML namespaces correctly

- [ ] Create SAMLProgrammaticGenerator class (AC: 1, 9)
  - [ ] Class: SAMLProgrammaticGenerator in src/ihe_test_util/saml/programmatic_generator.py
  - [ ] __init__(cert_bundle: Optional[CertificateBundle] = None)
  - [ ] Method: generate(subject: str, issuer: str, audience: str, **kwargs) -> SAMLAssertion
  - [ ] Method: generate_with_certificate(subject: str, audience: str, cert_bundle: CertificateBundle, **kwargs) -> SAMLAssertion
  - [ ] Auto-extract issuer from certificate subject DN in generate_with_certificate()
  - [ ] Return SAMLAssertion dataclass with all fields populated
  - [ ] Set generation_method to SAMLGenerationMethod.PROGRAMMATIC
  - [ ] Support optional attributes, validity_minutes, and conditions via kwargs

- [ ] Integrate with existing SAML infrastructure (AC: 9)
  - [ ] Import CertificateBundle from src/ihe_test_util/saml/certificate_manager.py
  - [ ] Import SAMLAssertion and SAMLGenerationMethod from src/ihe_test_util/models/saml.py
  - [ ] Reuse timestamp generation utilities if available from template_loader
  - [ ] Reuse assertion ID generation utilities if available from template_loader
  - [ ] Ensure consistent behavior between programmatic and template-based approaches
  - [ ] Update src/ihe_test_util/saml/__init__.py to export SAMLProgrammaticGenerator

- [ ] Implement parameter validation (AC: 2, 3)
  - [ ] Function: _validate_required_parameters(subject: str, issuer: str, audience: str) -> None
  - [ ] Check subject is non-empty string
  - [ ] Check issuer is non-empty string (should be URI format)
  - [ ] Check audience is non-empty string (should be URI format)
  - [ ] Raise ValueError with actionable message if validation fails
  - [ ] Validate validity_minutes is positive integer if provided
  - [ ] Validate attributes dict keys are valid SAML attribute names if provided

- [ ] Create comprehensive unit tests (AC: 10)
  - [ ] Create tests/unit/test_programmatic_generator.py
  - [ ] Test generate_saml_assertion with required parameters only
  - [ ] Test generate_saml_assertion with all optional parameters
  - [ ] Test SAML structure follows SAML 2.0 specification
  - [ ] Test assertion ID uniqueness (generate 100 assertions, verify all IDs unique)
  - [ ] Test timestamp generation in ISO 8601 format with Z suffix
  - [ ] Test validity period calculation (5 minutes default, custom values)
  - [ ] Test custom attribute statements with single attribute
  - [ ] Test custom attribute statements with multiple attributes
  - [ ] Test custom attribute statements with multi-valued attributes
  - [ ] Test attribute statement omitted when no attributes provided
  - [ ] Test canonicalization produces valid C14N output
  - [ ] Test SAMLAssertion dataclass population
  - [ ] Test generation_method set to PROGRAMMATIC
  - [ ] Test integration with CertificateBundle for issuer extraction
  - [ ] Test parameter validation for required fields
  - [ ] Test error handling for invalid parameters
  - [ ] Test error handling for invalid validity_minutes
  - [ ] Target 80%+ coverage for programmatic_generator.py

- [ ] Create integration tests (AC: 1, 8, 9)
  - [ ] Create or update tests/integration/test_saml_workflow.py
  - [ ] Test programmatic generation workflow end-to-end
  - [ ] Test generated SAML validates against SAML 2.0 structure (if validator available)
  - [ ] Test generated SAML is ready for signing (canonicalized)
  - [ ] Test integration with certificate manager from Story 4.1
  - [ ] Test both template-based and programmatic approaches produce valid SAML
  - [ ] Test programmatic SAML can be signed (integration with signxml - Story 4.4 dependency)
  - [ ] Test programmatic SAML can be embedded in WS-Security headers

- [ ] Create comparison and usage examples
  - [ ] Create examples/programmatic_saml_example.py
  - [ ] Demonstrate basic programmatic SAML generation
  - [ ] Demonstrate SAML generation with custom attributes
  - [ ] Demonstrate SAML generation with certificate integration
  - [ ] Show when to use programmatic vs template-based approach
  - [ ] Include commented examples of both simple and complex scenarios

- [ ] Update project documentation
  - [ ] Update docs/saml-guide.md (create if not exists)
  - [ ] Document programmatic SAML generation API
  - [ ] Document when to use programmatic vs template-based approach
  - [ ] Add examples for common SAML generation scenarios
  - [ ] Document parameter options and their effects
  - [ ] Document attribute statement formatting
  - [ ] Add troubleshooting section for common issues

## Dev Notes

### Previous Story Insights

[Source: Story 4.1 Completion - Certificate Management & Loading]

**Certificate Manager Available:**
- Location: `src/ihe_test_util/saml/certificate_manager.py` (production-ready)
- Certificate loading supports PEM, PKCS12, DER formats
- CertificateBundle dataclass includes: certificate, private_key, chain, info
- CertificateInfo includes: subject, issuer, expiration, key size
- 88% test coverage, 34/34 unit tests pass
- Certificate management complete and ready for issuer identity extraction

**Integration Point:**
- SAML issuer can be extracted from certificate subject DN
- Programmatic generator should accept CertificateBundle for automatic issuer extraction
- Method: generate_with_certificate() should use cert_bundle.info.subject for issuer

[Source: Story 4.2 Completion - Template-Based SAML Generation]

**Template-Based SAML Generation Complete:**
- Location: `src/ihe_test_util/saml/template_loader.py` (production-ready)
- Timestamp generation: ISO 8601 format with Z suffix (YYYY-MM-DDTHH:MM:SSZ)
- Assertion ID generation: UUID4 with underscore prefix (e.g., _a1b2c3d4e5f6...)
- XML canonicalization: lxml.etree with method='c14n'
- SAMLAssertion dataclass usage established
- 87% test coverage, 37/37 unit tests pass

**Reusable Patterns:**
- Timestamp generation utility can be shared or duplicated
- Assertion ID generation utility can be shared or duplicated
- Canonicalization approach using lxml is established
- SAMLAssertion dataclass construction patterns available

**Key Difference:**
- Template-based: Loads XML template, replaces placeholders
- Programmatic: Builds XML structure from scratch using lxml.etree

[Source: Spike 1.2 - XML Signing Validation]

**Spike Findings:**
- signxml library selected for XML signing (Story 4.4 dependency)
- Basic SAML assertion generation demonstrated in examples/signxml_saml_example.py
- Used lxml.etree for building SAML structure
- Confirmed SAML 2.0 structure requirements
- Canonicalization approach validated

**Example Pattern from Spike:**
```python
from lxml import etree

SAML_NS = "urn:oasis:names:tc:SAML:2.0:assertion"

assertion = etree.Element(
    f"{{{SAML_NS}}}Assertion",
    attrib={
        "ID": assertion_id,
        "Version": "2.0",
        "IssueInstant": issue_instant
    }
)
```

### Tech Stack

[Source: architecture/tech-stack.md]

**Core Libraries for Programmatic SAML Generation:**

- **lxml 5.1+** - XML construction, parsing, and canonicalization
  - `lxml.etree.Element()` - Create XML elements programmatically
  - `lxml.etree.SubElement()` - Add child elements
  - `lxml.etree.tostring(method='c14n')` - C14N canonicalization
  - `lxml.etree.QName()` - Handle XML namespaces
  - High performance, standards-compliant

- **signxml 3.2+** - XML signing (Story 4.4, but canonicalized output needed now)
  - Requires canonicalized XML input
  - Pure Python, zero compilation

- **Python Built-ins:**
  - `uuid` - Generate unique assertion IDs
  - `datetime` - Timestamp generation (UTC)
  - `logging` - All messages (RULE 1)
  - `typing` - Type hints (RULE 7)

**No New Dependencies Required** - All libraries already in project

### File Locations

[Source: architecture/source-tree.md]

**Files to CREATE:**

```
src/ihe_test_util/saml/
├── programmatic_generator.py    # Programmatic SAML generation (NEW)
└── __init__.py                  # Update exports

examples/
├── programmatic_saml_example.py # Programmatic SAML examples (NEW)

tests/unit/
├── test_programmatic_generator.py # Unit tests for programmatic SAML (NEW)

tests/integration/
├── test_saml_workflow.py        # Update with programmatic tests
```

**Files to REFERENCE (already exist):**

```
src/ihe_test_util/saml/
├── certificate_manager.py       # Certificate loading (Story 4.1, completed)
├── template_loader.py           # Template-based SAML (Story 4.2, completed)
└── __init__.py                  # Module exports

src/ihe_test_util/models/
├── saml.py                      # SAMLAssertion dataclass (already exists)

examples/
├── signxml_saml_example.py      # Spike 1.2 SAML generation patterns
```

### SAML 2.0 Programmatic Structure

[Source: OASIS SAML 2.0 Specification + Architecture + Story 4.2]

**Required SAML 2.0 Elements Structure:**

The programmatic generator must build this exact XML structure using lxml.etree:

```python
from lxml import etree

SAML_NS = "urn:oasis:names:tc:SAML:2.0:assertion"

# Root: <saml:Assertion>
assertion = etree.Element(
    f"{{{SAML_NS}}}Assertion",
    nsmap={'saml': SAML_NS},
    attrib={
        "ID": assertion_id,
        "Version": "2.0",
        "IssueInstant": issue_instant
    }
)

# <saml:Issuer>
issuer_elem = etree.SubElement(assertion, f"{{{SAML_NS}}}Issuer")
issuer_elem.text = issuer

# <saml:Subject>
subject_elem = etree.SubElement(assertion, f"{{{SAML_NS}}}Subject")
name_id = etree.SubElement(
    subject_elem, 
    f"{{{SAML_NS}}}NameID",
    attrib={"Format": "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"}
)
name_id.text = subject

subject_confirmation = etree.SubElement(
    subject_elem,
    f"{{{SAML_NS}}}SubjectConfirmation",
    attrib={"Method": "urn:oasis:names:tc:SAML:2.0:cm:bearer"}
)

subject_conf_data = etree.SubElement(
    subject_confirmation,
    f"{{{SAML_NS}}}SubjectConfirmationData",
    attrib={"NotOnOrAfter": not_on_or_after}
)

# <saml:Conditions>
conditions = etree.SubElement(
    assertion,
    f"{{{SAML_NS}}}Conditions",
    attrib={
        "NotBefore": not_before,
        "NotOnOrAfter": not_on_or_after
    }
)

audience_restriction = etree.SubElement(conditions, f"{{{SAML_NS}}}AudienceRestriction")
audience_elem = etree.SubElement(audience_restriction, f"{{{SAML_NS}}}Audience")
audience_elem.text = audience

# <saml:AuthnStatement>
authn_statement = etree.SubElement(
    assertion,
    f"{{{SAML_NS}}}AuthnStatement",
    attrib={
        "AuthnInstant": authn_instant,
        "SessionIndex": assertion_id
    }
)

authn_context = etree.SubElement(authn_statement, f"{{{SAML_NS}}}AuthnContext")
authn_context_class_ref = etree.SubElement(authn_context, f"{{{SAML_NS}}}AuthnContextClassRef")
authn_context_class_ref.text = "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport"

# <saml:AttributeStatement> (if attributes provided)
if attributes:
    attr_statement = etree.SubElement(assertion, f"{{{SAML_NS}}}AttributeStatement")
    for attr_name, attr_value in attributes.items():
        attr = etree.SubElement(attr_statement, f"{{{SAML_NS}}}Attribute", attrib={"Name": attr_name})
        attr_value_elem = etree.SubElement(attr, f"{{{SAML_NS}}}AttributeValue")
        attr_value_elem.text = str(attr_value)
```

### Timestamp and ID Generation

[Source: Story 4.2 - Template-Based SAML Generation]

**Reuse or Duplicate These Patterns:**

```python
from datetime import datetime, timedelta
import uuid

def generate_assertion_id() -> str:
    """Generate unique SAML assertion ID.
    
    Returns:
        Unique assertion ID starting with underscore
        
    Example:
        >>> generate_assertion_id()
        '_a1b2c3d4e5f6789012345678901234567890'
    """
    return f"_{uuid.uuid4().hex}"

def generate_saml_timestamps(validity_minutes: int = 5) -> dict[str, str]:
    """Generate SAML timestamps in ISO 8601 format.
    
    Args:
        validity_minutes: Assertion validity period in minutes
        
    Returns:
        dict with keys: issue_instant, not_before, not_on_or_after
        
    Example:
        >>> generate_saml_timestamps(5)
        {
            'issue_instant': '2025-11-11T11:00:00Z',
            'not_before': '2025-11-11T11:00:00Z',
            'not_on_or_after': '2025-11-11T11:05:00Z'
        }
    """
    now = datetime.utcnow()
    not_on_or_after = now + timedelta(minutes=validity_minutes)
    
    return {
        'issue_instant': now.strftime('%Y-%m-%dT%H:%M:%SZ'),
        'not_before': now.strftime('%Y-%m-%dT%H:%M:%SZ'),
        'not_on_or_after': not_on_or_after.strftime('%Y-%m-%dT%H:%M:%SZ')
    }
```

**Note:** These functions can be moved to a shared utility module if desired, or duplicated in programmatic_generator.py to keep it self-contained.

### XML Canonicalization

[Source: Story 4.2 + Spike 1.2]

**Canonicalization for Signing:**

```python
from lxml import etree

def canonicalize_assertion(assertion: etree.Element) -> str:
    """Canonicalize SAML assertion for signing.
    
    Args:
        assertion: SAML assertion XML element
        
    Returns:
        Canonicalized XML string (C14N format)
    """
    return etree.tostring(assertion, method='c14n').decode('utf-8')
```

### Data Models

[Source: architecture/data-models.md]

**SAMLAssertion Dataclass (already exists in models/saml.py):**

```python
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class SAMLGenerationMethod(Enum):
    TEMPLATE = "template"
    PROGRAMMATIC = "programmatic"

@dataclass
class SAMLAssertion:
    assertion_id: str
    issuer: str
    subject: str
    audience: str
    issue_instant: datetime
    not_before: datetime
    not_on_or_after: datetime
    xml_content: str
    signature: str  # Empty until Story 4.4 (signing)
    certificate_subject: str
    generation_method: SAMLGenerationMethod
```

**Usage in Programmatic Generator:**

```python
def generate(self, subject: str, issuer: str, audience: str, **kwargs) -> SAMLAssertion:
    # Generate assertion XML using lxml
    assertion_elem = self._build_assertion(subject, issuer, audience, **kwargs)
    
    # Canonicalize for signing
    xml_content = canonicalize_assertion(assertion_elem)
    
    # Parse timestamps for dataclass
    timestamps = generate_saml_timestamps(kwargs.get('validity_minutes', 5))
    
    # Create SAMLAssertion dataclass
    return SAMLAssertion(
        assertion_id=kwargs['assertion_id'],
        issuer=issuer,
        subject=subject,
        audience=audience,
        issue_instant=datetime.fromisoformat(timestamps['issue_instant'].replace('Z', '+00:00')),
        not_before=datetime.fromisoformat(timestamps['not_before'].replace('Z', '+00:00')),
        not_on_or_after=datetime.fromisoformat(timestamps['not_on_or_after'].replace('Z', '+00:00')),
        xml_content=xml_content,
        signature="",  # Signing happens in Story 4.4
        certificate_subject=kwargs.get('certificate_subject', ''),
        generation_method=SAMLGenerationMethod.PROGRAMMATIC
    )
```

### Coding Standards

[Source: architecture/coding-standards.md]

**CRITICAL RULES - MUST FOLLOW:**

1. **RULE 1: Never use print() statements**
   - Use logging module for all messages
   - Example: `logger.info("Generated SAML assertion")` not `print("Generated SAML assertion")`

2. **RULE 4: All file I/O MUST use Path objects**
   - Not applicable to this story (no file I/O in programmatic generation)

3. **RULE 5: Exceptions must include actionable context**
   - Error messages explain what failed and suggest fixes
   - Example: `raise ValueError(f"Issuer must be a non-empty string, got: {issuer!r}")`

4. **RULE 6: No bare except clauses**
   - Always catch specific exceptions
   - Example: `except ValueError` not `except:`

5. **RULE 7: Type hints are mandatory**
   - All functions must have complete type hints
   - Example: `def generate_saml_assertion(subject: str, issuer: str, audience: str, **kwargs) -> SAMLAssertion:`

**Google-Style Docstrings:**

```python
def generate_saml_assertion(
    subject: str,
    issuer: str,
    audience: str,
    attributes: Optional[dict[str, str]] = None,
    validity_minutes: int = 5
) -> SAMLAssertion:
    """Generate SAML 2.0 assertion programmatically.
    
    Creates a complete SAML 2.0 assertion with all required elements
    following the OASIS SAML 2.0 specification. The assertion is
    canonicalized and ready for XML signing.
    
    Args:
        subject: Subject (user) identifier
        issuer: Issuer identifier (URI format)
        audience: Intended audience (endpoint URL or identifier)
        attributes: Optional custom attributes (key-value pairs)
        validity_minutes: Assertion validity period in minutes (default: 5)
        
    Returns:
        SAMLAssertion dataclass with xml_content ready for signing
        
    Raises:
        ValueError: If required parameters are invalid or empty
        
    Example:
        >>> generator = SAMLProgrammaticGenerator()
        >>> assertion = generator.generate(
        ...     subject="user@example.com",
        ...     issuer="https://idp.example.com",
        ...     audience="https://sp.example.com",
        ...     attributes={"role": "physician"},
        ...     validity_minutes=10
        ... )
        >>> assert assertion.generation_method == SAMLGenerationMethod.PROGRAMMATIC
    """
```

### Testing

[Source: architecture/test-strategy-and-standards.md]

**Test File Locations:**
- **Unit Tests:** `tests/unit/test_programmatic_generator.py`
- **Integration Tests:** `tests/integration/test_saml_workflow.py` (update existing)

**Test Coverage Goal:**
- **Minimum:** 75% (CI requirement)
- **Target:** 80%+ for programmatic_generator.py
- **Critical paths:** 100% (SAML generation, validation, canonicalization)

**Testing Approach:**

**Unit Tests (with pytest):**

```python
import pytest
from datetime import datetime
from lxml import etree
from ihe_test_util.saml.programmatic_generator import (
    generate_saml_assertion,
    generate_assertion_id,
    generate_saml_timestamps,
    SAMLProgrammaticGenerator
)
from ihe_test_util.models.saml import SAMLGenerationMethod

def test_generate_saml_assertion_required_params():
    """Test SAML generation with only required parameters."""
    assertion = generate_saml_assertion(
        subject="user@example.com",
        issuer="https://idp.example.com",
        audience="https://sp.example.com"
    )
    
    assert assertion.subject == "user@example.com"
    assert assertion.issuer == "https://idp.example.com"
    assert assertion.audience == "https://sp.example.com"
    assert assertion.generation_method == SAMLGenerationMethod.PROGRAMMATIC
    assert "<saml:Assertion" in assertion.xml_content
    assert "user@example.com" in assertion.xml_content

def test_generate_saml_assertion_with_attributes():
    """Test SAML generation with custom attributes."""
    assertion = generate_saml_assertion(
        subject="user@example.com",
        issuer="https://idp.example.com",
        audience="https://sp.example.com",
        attributes={"role": "physician", "organization": "Hospital A"}
    )
    
    assert "<saml:AttributeStatement>" in assertion.xml_content
    assert "physician" in assertion.xml_content
    assert "Hospital A" in assertion.xml_content

def test_generate_assertion_id_uniqueness():
    """Test assertion ID generation produces unique values."""
    ids = set()
    for _ in range(100):
        assertion_id = generate_assertion_id()
        assert assertion_id.startswith("_")
        assert len(assertion_id) == 33  # _ + 32 hex chars
        ids.add(assertion_id)
    
    assert len(ids) == 100  # All unique

def test_generate_saml_timestamps_validity_period():
    """Test SAML timestamp generation with custom validity."""
    timestamps = generate_saml_timestamps(validity_minutes=10)
    
    assert 'issue_instant' in timestamps
    assert 'not_before' in timestamps
    assert 'not_on_or_after' in timestamps
    
    # Verify ISO 8601 format with Z suffix
    assert timestamps['issue_instant'].endswith('Z')
    
    # Parse and verify validity period
    issue_instant = datetime.fromisoformat(timestamps['issue_instant'].replace('Z', '+00:00'))
    not_on_or_after = datetime.fromisoformat(timestamps['not_on_or_after'].replace('Z', '+00:00'))
    
    delta = not_on_or_after - issue_instant
    assert delta.total_seconds() == 600  # 10 minutes

def test_programmatic_generator_with_certificate():
    """Test SAMLProgrammaticGenerator with certificate integration."""
    from ihe_test_util.saml.certificate_manager import load_certificate
    from pathlib import Path
    
    # Load test certificate
    cert_bundle = load_certificate(Path("tests/fixtures/test_cert.pem"))
    
    # Generate SAML with certificate info
    generator = SAMLProgrammaticGenerator(cert_bundle=cert_bundle)
    assertion = generator.generate_with_certificate(
        subject="user@example.com",
        audience="https://sp.example.com"
    )
    
    # Issuer should be extracted from certificate subject
    assert assertion.issuer == cert_bundle.info.subject
    assert assertion.certificate_subject == cert_bundle.info.subject

def test_parameter_validation_empty_subject():
    """Test parameter validation rejects empty subject."""
    with pytest.raises(ValueError, match="subject.*non-empty"):
        generate_saml_assertion(
            subject="",
            issuer="https://idp.example.com",
            audience="https://sp.example.com"
        )

def test_canonicalization_produces_valid_c14n():
    """Test canonicalization produces valid C14N output."""
    assertion = generate_saml_assertion(
        subject="user@example.com",
        issuer="https://idp.example.com",
        audience="https://sp.example.com"
    )
    
    # Parse XML to verify it's well-formed
    tree = etree.fromstring(assertion.xml_content.encode('utf-8'))
    assert tree.tag.endswith("}Assertion")
    
    # Verify canonicalization (no extra whitespace, consistent namespace declarations)
    assert "\n\n" not in assertion.xml_content  # No double newlines
```

**Integration Tests:**

```python
def test_programmatic_vs_template_saml_compatibility():
    """Test that programmatic and template-based SAML are compatible."""
    from pathlib import Path
    from ihe_test_util.saml.template_loader import SAMLTemplatePersonalizer
    from ihe_test_util.saml.programmatic_generator import SAMLProgrammaticGenerator
    
    # Generate SAML using both methods
    prog_gen = SAMLProgrammaticGenerator()
    prog_assertion = prog_gen.generate(
        subject="user@example.com",
        issuer="https://idp.example.com",
        audience="https://sp.example.com"
    )
    
    templ_gen = SAMLTemplatePersonalizer()
    templ_assertion = templ_gen.personalize(
        Path("templates/saml-minimal.xml"),
        {
            "subject": "user@example.com",
            "issuer": "https://idp.example.com",
            "audience": "https://sp.example.com"
        }
    )
    
    # Both should have required elements
    assert "<saml:Assertion" in prog_assertion.xml_content
    assert "<saml:Assertion" in templ_assertion.xml_content
    assert "user@example.com" in prog_assertion.xml_content
    assert "user@example.com" in templ_assertion.xml_content
```

### Integration Points

**Upstream Dependencies:**
- Story 4.1: Certificate Management (completed) - provides CertificateBundle for issuer extraction
- Story 4.2: Template-Based SAML (completed) - establishes SAMLAssertion dataclass usage and patterns

**Downstream Usage:**
- Story 4.4: XML Signature Implementation (signs programmatically-generated SAML)
- Story 4.5: WS-Security Header Construction (embeds signed programmatic SAML in SOAP headers)
- Story 5.x: PIX Add Transaction (uses programmatic SAML for authentication)
- Story 6.x: ITI-41 Transaction (uses programmatic SAML for authentication)

**No Circular Dependencies** - Programmatic SAML generation is independent

### When to Use Programmatic vs Template-Based

**Use Programmatic Generation When:**
- Standard SAML structure is sufficient
- No organization-specific SAML template available
- Need maximum flexibility to customize structure programmatically
- Generating SAML in code with dynamic parameters
- Building automated test fixtures

**Use Template-Based Generation When:**
- Organization provides specific SAML template
- Complex custom SAML structure with many conditional elements
- Need to match exact XML structure from existing system
- Non-technical users need to modify SAML structure
- Template is managed separately from code

**Both Approaches:**
- Produce valid SAML 2.0 assertions
- Use same SAMLAssertion dataclass
- Can be signed with signxml (Story 4.4)
- Can be embedded in WS-Security headers (Story 4.5)

### Example Usage

**Basic Programmatic SAML Generation:**
```python
from ihe_test_util.saml.programmatic_generator import SAMLProgrammaticGenerator

# Initialize generator
generator = SAMLProgrammaticGenerator()

# Generate SAML assertion
assertion = generator.generate(
    subject="dr.smith@hospital.org",
    issuer="https://idp.hospital.org",
    audience="https://xds.regional-hie.org"
)

print(f"Generated SAML: {assertion.assertion_id}")
print(f"Valid until: {assertion.not_on_or_after}")
```

**With Custom Attributes:**
```python
assertion = generator.generate(
    subject="dr.smith@hospital.org",
    issuer="https://idp.hospital.org",
    audience="https://xds.regional-hie.org",
    attributes={
        "username": "dr.smith",
        "role": "physician",
        "organization": "General Hospital",
        "department": "Cardiology"
    },
    validity_minutes=10
)
```

**With Certificate Integration:**
```python
from pathlib import Path
from ihe_test_util.saml.certificate_manager import load_certificate

# Load certificate
cert_bundle = load_certificate(Path("certs/saml-idp.p12"), password=b"secret")

# Generate SAML with certificate issuer
generator = SAMLProgrammaticGenerator(cert_bundle=cert_bundle)
assertion = generator.generate_with_certificate(
    subject="dr.smith@hospital.org",
    audience="https://xds.regional-hie.org"
)

# Issuer automatically extracted from certificate subject
print(f"Issuer: {assertion.issuer}")  # From cert_bundle.info.subject
```

## QA Results

### Review Date: 2025-11-11

### Reviewed By: Quinn (Test Architect)

### Executive Summary

**Outstanding implementation.** Story 4.3 delivers production-ready programmatic SAML 2.0 generation with exceptional code quality, comprehensive test coverage (100% unit, 93% integration), and excellent documentation. All 10 acceptance criteria fully met with zero defects found.

### Test Execution Results

**Unit Tests:**
- Command: `python -m pytest tests/unit/test_programmatic_generator.py -v`
- Result: **48/48 PASSED ✅**
- Coverage: **100%** on `programmatic_generator.py`
- Test Quality: Comprehensive coverage of all functions and edge cases

**Integration Tests:**
- Command: `python -m pytest tests/integration/test_programmatic_saml_workflow.py -v`
- Result: **11/12 PASSED ✅, 1 SKIPPED**
- Coverage: **93%** on `programmatic_generator.py`
- Skipped Test: PKCS12 certificate integration (test fixture dependency, non-blocking)
- Integration Quality: Excellent end-to-end workflow validation

### Requirements Traceability (Given-When-Then)

**AC1: SAML generator creates SAML 2.0 assertion from parameters**
- **Given** a SAMLProgrammaticGenerator instance
- **When** I call `generate()` with subject, issuer, audience
- **Then** a valid SAMLAssertion dataclass is returned
- **Coverage**: ✅ `test_generate_with_required_params_only`

**AC2: Required parameters: subject, issuer, audience**
- **Given** the `generate()` method
- **When** I provide subject, issuer, and audience
- **Then** all three parameters are validated and included in assertion
- **Coverage**: ✅ `test_validate_required_parameters`, `test_empty_*_raises`

**AC3: Optional parameters: attributes, conditions, validity duration**
- **Given** the `generate()` method with optional parameters
- **When** I provide attributes and validity_minutes
- **Then** they are correctly applied to the SAML assertion
- **Coverage**: ✅ `test_generate_with_all_params`, `test_custom_validity_period`

**AC4: Generated assertion follows SAML 2.0 specification structure**
- **Given** a generated SAML assertion
- **When** I parse the XML content
- **Then** it contains all required SAML 2.0 elements (Assertion, Issuer, Subject, Conditions, AuthnStatement)
- **Coverage**: ✅ `test_generate_includes_required_elements`, `test_saml_structure_follows_spec`

**AC5: Assertion includes AuthnStatement with timestamp**
- **Given** a generated SAML assertion
- **When** I inspect the AuthnStatement element
- **Then** it contains AuthnInstant timestamp and SessionIndex
- **Coverage**: ✅ `test_includes_authn_context`, `test_includes_authn_context_class_ref`

**AC6: Configurable assertion validity period (default 5 minutes)**
- **Given** the `generate()` method
- **When** I specify validity_minutes or use default
- **Then** NotBefore and NotOnOrAfter timestamps reflect the correct period
- **Coverage**: ✅ `test_default_validity_period`, `test_custom_validity_period`, `test_generate_validity_period`

**AC7: Support for custom attribute statements**
- **Given** the `generate()` method with attributes dict
- **When** I provide single-valued and multi-valued attributes
- **Then** AttributeStatement contains all attributes with correct structure
- **Coverage**: ✅ `test_adds_single_valued_attribute`, `test_adds_multi_valued_attribute`, `test_generate_multi_valued_attributes`

**AC8: Generated SAML properly formatted and canonicalized for signing**
- **Given** a generated SAML assertion
- **When** I inspect the xml_content
- **Then** it is valid C14N canonicalized XML ready for signing
- **Coverage**: ✅ `test_canonical_xml_parseable`, `test_saml_canonicalization_for_signing`

**AC9: Integration with certificate management for issuer identity**
- **Given** a SAMLProgrammaticGenerator with CertificateBundle
- **When** I call `generate_with_certificate()`
- **Then** issuer is automatically extracted from certificate subject DN
- **Coverage**: ✅ `test_generate_with_certificate_auto_extracts_issuer`, `test_integration_with_certificate_manager`

**AC10: Unit tests verify SAML structure, validity periods, attribute handling**
- **Given** the comprehensive test suite
- **When** all tests execute
- **Then** 48/48 unit tests pass covering all functionality
- **Coverage**: ✅ All test classes (TestGenerateAssertionId, TestGenerateSamlTimestamps, etc.)

### Code Quality Assessment

**Architecture & Design: Excellent (95/100)**
- Clean separation of concerns with helper functions for each SAML element
- Proper use of lxml.etree for programmatic XML construction
- SAMLProgrammaticGenerator class provides intuitive API
- Reusable utility functions (generate_assertion_id, generate_saml_timestamps)
- Excellent modularity - each function has single responsibility

**Coding Standards Compliance: Perfect (100/100)**
- ✅ RULE 1: No print() statements - uses logging module throughout
- ✅ RULE 5: Actionable error messages with context
- ✅ RULE 6: No bare except clauses - specific exception handling
- ✅ RULE 7: Complete type hints on all functions
- ✅ Google-style docstrings with examples on all public functions
- ✅ Consistent code formatting and style

**Error Handling: Excellent (95/100)**
- Comprehensive parameter validation with actionable error messages
- Proper ValueError exceptions for invalid inputs
- Clear error messages guide users to fix issues
- Examples: `"Subject must be a non-empty string, got: {subject!r}. Provide a valid user or patient identifier."`

**Documentation: Outstanding (100/100)**
- Comprehensive module docstring
- Google-style docstrings on all functions and classes
- Inline code examples in docstrings
- Excellent example file: `examples/programmatic_saml_example.py` with 7 scenarios
- Clear guidance on when to use programmatic vs template-based generation

**Test Coverage: Excellent (98/100)**
- 48 unit tests covering all functions and edge cases
- 12 integration tests covering end-to-end workflows
- 100% coverage on programmatic_generator.py
- Tests verify SAML structure, timestamps, attributes, certificate integration
- Edge cases: empty parameters, invalid validity_minutes, multi-valued attributes
- Minor: 1 integration test skipped (PKCS12 certificate - test fixture dependency)

### Non-Functional Requirements (NFRs)

**Security: PASS ✅**
- Proper timestamp generation using UTC timezone
- Input validation prevents injection attacks
- Unique assertion ID generation using UUID4
- Integration with certificate management for issuer identity
- Notes: Security assessment excellent, no concerns

**Performance: PASS ✅**
- Efficient lxml-based XML generation
- Batch generation test: 100 assertions in < 1 second
- Suitable for high-volume scenarios
- No performance bottlenecks identified
- Notes: Performance excellent for typical IHE workflows

**Reliability: PASS ✅**
- Comprehensive error handling with actionable messages
- Input validation prevents invalid SAML generation
- Timestamp validation ensures correct validity periods
- 59 test cases provide confidence in reliability
- Notes: Production-ready reliability

**Maintainability: PASS ✅**
- Modular design with single-responsibility functions
- Comprehensive documentation and examples
- Clear code structure following project standards
- Type hints improve IDE support and refactoring
- Notes: Highly maintainable, excellent developer experience

### Compliance Check

- **Coding Standards**: ✅ Perfect compliance with all rules
- **Project Structure**: ✅ Files in correct locations per source tree
- **Testing Strategy**: ✅ Exceeds 80% coverage target
- **All ACs Met**: ✅ All 10 acceptance criteria fully implemented

### Testability Evaluation

- **Controllability**: ✅ Excellent - all inputs controllable via parameters
- **Observability**: ✅ Excellent - XML output fully inspectable
- **Debuggability**: ✅ Excellent - clear logging and error messages

### Technical Debt Identification

**None identified.** This implementation introduces zero technical debt.

### Integration Points Validation

- ✅ **Story 4.1 (Certificate Management)**: Seamless integration via CertificateBundle
- ✅ **Story 4.2 (Template SAML)**: Compatible SAMLAssertion dataclass usage
- ✅ **Models/SAML**: Proper use of SAMLGenerationMethod.PROGRAMMATIC
- ✅ **Ready for Story 4.4 (Signing)**: xml_content is canonicalized and signing-ready

### Refactoring Performed

**None required.** Code quality is exceptional from initial implementation.

### Security Review

**No security concerns identified.**

- Proper UTC timestamp handling prevents timezone attacks
- Input validation prevents XML injection
- Unique ID generation using cryptographically secure UUID4
- No sensitive data exposure in logs

### Performance Considerations

**No performance concerns identified.**

- Batch generation performance excellent (100 assertions < 1s)
- Suitable for IHE transaction volumes
- Efficient memory usage with lxml

### Files Modified During Review

**None.** No refactoring or modifications needed.

### Risk Assessment

**Overall Risk: Very Low**

| Risk Area | Probability | Impact | Score | Mitigation |
|-----------|-------------|---------|-------|------------|
| SAML Spec Compliance | Very Low | High | 2 | Comprehensive tests validate structure |
| Certificate Integration | Very Low | Medium | 1 | Tested with Story 4.1 integration |
| Multi-valued Attributes | Very Low | Medium | 1 | Explicit tests cover this feature |
| Timestamp Validation | Very Low | Medium | 1 | UTC handling, comprehensive tests |
| Performance | Very Low | Low | 0 | Batch tests confirm efficiency |

**Risk Score Legend**: Critical (≥9), High (6-8), Medium (3-5), Low (1-2), Minimal (0)

### Quality Score

**Quality Score: 98/100**

**Calculation**: 100 - (0 × 20 FAILs) - (0 × 10 CONCERNS) = 100, adjusted to 98 for PKCS12 test skip

### Recommendations

**Immediate (Required Before Production): None**

**Future Enhancements (Optional):**
1. ✅ Consider shared utility module for timestamp/ID generation (could be reused in other SAML modules)
   - **Note**: Current duplication is acceptable - keeps module self-contained
2. ✅ Add PKCS12 test fixture to enable skipped integration test
   - **Note**: Non-blocking, PEM certificates fully tested

### Gate Status

**Gate: PASS** → docs/qa/gates/4.3-programmatic-saml-generation.yml

**Status Reason**: All acceptance criteria met with exceptional implementation quality. Zero defects, 100% unit test coverage, comprehensive documentation, and production-ready code.

### Recommended Status

**✅ Ready for Done**

This story exceeds quality expectations and is ready for production use. The implementation demonstrates exemplary software engineering practices with comprehensive testing, excellent documentation, and zero technical debt.

### Key Strengths

1. **Exceptional Test Coverage**: 48 unit + 12 integration tests, 100% coverage on target module
2. **Outstanding Documentation**: Comprehensive docstrings, examples, and usage guidance
3. **Zero Defects**: No issues found during comprehensive review
4. **Production-Ready**: All NFRs met, no technical debt introduced
5. **Excellent Developer Experience**: Clear API, helpful error messages, great examples
6. **SAML 2.0 Compliant**: Follows specification precisely
7. **Flexible Design**: Supports both simple and complex use cases (multi-valued attributes, certificate integration)

### Conclusion

Story 4.3 represents exemplary implementation quality. The programmatic SAML generation capability complements the template-based approach from Story 4.2, giving developers flexibility to choose the best approach for their use case. Ready for immediate production deployment.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-11 | 1.0 | Initial story creation for Epic 4 | Scrum Master (Bob) |
| 2025-11-11 | 1.1 | PO validation complete - Enhanced Task 6 with explicit multi-valued attribute implementation guidance - APPROVED for development | Product Owner (Sarah) |
| 2025-11-11 | 1.2 | QA review complete - PASS gate with 98/100 quality score - Zero defects found, exceptional implementation quality | Quinn (Test Architect) |
