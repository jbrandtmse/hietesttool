# Story 4.4: XML Signature Implementation

## Status
Done

## Story

**As a** developer,
**I want** to sign SAML assertions using XML signatures,
**so that** I can create authenticated assertions for IHE transactions.

## Acceptance Criteria

1. XML signing using `signxml` library
2. Signature algorithm configurable (default RSA-SHA256)
3. XML canonicalization (C14N) applied before signing to prevent tampering
4. Signature includes KeyInfo with certificate reference
5. Signed SAML assertion validates against XML signature specification
6. Signature verification function validates signed assertions
7. Clear error messages for signing failures, invalid keys, corrupted XML
8. Timestamp freshness validated when verifying signatures
9. Performance optimization for batch signing operations
10. Unit tests verify signing, verification, canonicalization, error cases

## Tasks / Subtasks

- [ ] Review existing SAML infrastructure and spike findings (AC: 1, 2, 3, 4)
  - [ ] Review src/ihe_test_util/saml/certificate_manager.py (Story 4.1 - certificate loading)
  - [ ] Review src/ihe_test_util/saml/template_loader.py (Story 4.2 - template-based SAML)
  - [ ] Review src/ihe_test_util/saml/programmatic_generator.py (Story 4.3 - programmatic SAML)
  - [ ] Review docs/spike-findings-1.2-xml-signing-validation.md (signxml spike findings)
  - [ ] Review examples/signxml_saml_example.py (spike implementation patterns)
  - [ ] Understand SAMLAssertion dataclass structure from models/saml.py
  - [ ] Identify canonicalized XML output from template_loader and programmatic_generator

- [ ] Create XML signature module structure (AC: 1, 2)
  - [ ] Create src/ihe_test_util/saml/signer.py module
  - [ ] Import signxml library (SignatureMethod, DigestAlgorithm, XMLSigner)
  - [ ] Import certificate_manager for CertificateBundle integration
  - [ ] Import SAMLAssertion from models/saml.py
  - [ ] Add proper type hints (RULE 7)
  - [ ] Add Google-style docstrings with examples
  - [ ] Use logging module for all messages (RULE 1)

- [ ] Implement SAMLSigner class (AC: 1, 2, 3, 4)
  - [ ] Class: SAMLSigner in src/ihe_test_util/saml/signer.py
  - [ ] __init__(cert_bundle: CertificateBundle, signature_algorithm: str = "RSA-SHA256")
  - [ ] Validate certificate_bundle has required certificate and private_key
  - [ ] Map signature_algorithm string to SignatureMethod enum (RSA-SHA256, RSA-SHA512, etc.)
  - [ ] Store certificate and key in instance variables
  - [ ] Default to RSA-SHA256 with SHA256 digest (most common for IHE)
  - [ ] Raise ValueError with actionable context for invalid algorithm (RULE 5)

- [ ] Implement SAML assertion signing method (AC: 3, 4, 5)
  - [ ] Method: sign_assertion(saml_assertion: SAMLAssertion) -> SAMLAssertion
  - [ ] Parse saml_assertion.xml_content using lxml.etree.fromstring()
  - [ ] Create XMLSigner with configured signature_algorithm and digest_algorithm
  - [ ] Call signer.sign() with assertion element, private key, and certificate
  - [ ] Signature inserted as child element of <saml:Assertion>
  - [ ] Canonicalization algorithm: C14N 1.1 (http://www.w3.org/2006/12/xml-c14n11)
  - [ ] Signature method: RSA-SHA256 (http://www.w3.org/2001/04/xmldsig-more#rsa-sha256)
  - [ ] Digest algorithm: SHA256 (http://www.w3.org/2001/04/xmlenc#sha256)
  - [ ] KeyInfo includes X509Certificate element with certificate
  - [ ] Return new SAMLAssertion with updated xml_content and signature field populated
  - [ ] Log signing operation (logger.info) with assertion ID (RULE 1)

- [ ] Handle signing errors with actionable messages (AC: 7)
  - [ ] Catch lxml.etree.XMLSyntaxError for malformed XML
    - [ ] Error message: "Invalid XML structure in SAML assertion: {error}. Ensure xml_content is well-formed XML."
  - [ ] Catch signxml.exceptions.InvalidInput for invalid certificate/key
    - [ ] Error message: "Invalid certificate or private key: {error}. Verify certificate bundle is correct."
  - [ ] Catch signxml.exceptions.InvalidSignature during signing (shouldn't happen but catch)
    - [ ] Error message: "Signing failed: {error}. This may indicate corrupted certificate or key."
  - [ ] Catch Exception as fallback with generic error
    - [ ] Error message: "Unexpected error during SAML signing: {error}. Check certificate, key, and XML content."
  - [ ] All error messages must be actionable (RULE 5)
  - [ ] No bare except clauses (RULE 6)

- [ ] Implement signature verification module (AC: 5, 6, 8)
  - [ ] Create src/ihe_test_util/saml/verifier.py module
  - [ ] Class: SAMLVerifier
  - [ ] __init__(cert_bundle: Optional[CertificateBundle] = None)
  - [ ] Method: verify_assertion(saml_assertion: SAMLAssertion, cert: Optional[str] = None) -> bool
  - [ ] Parse saml_assertion.xml_content using lxml.etree.fromstring()
  - [ ] Create XMLVerifier instance
  - [ ] Call verifier.verify() with signed assertion and certificate
  - [ ] Use cert parameter if provided, otherwise use cert_bundle.certificate
  - [ ] Return True if verification succeeds, False or raise exception if fails
  - [ ] Log verification result (logger.info for success, logger.warning for failure)

- [ ] Implement timestamp freshness validation (AC: 8)
  - [ ] Method: validate_timestamp_freshness(saml_assertion: SAMLAssertion, max_age_minutes: int = 5) -> bool
  - [ ] Compare saml_assertion.issue_instant with current UTC time
  - [ ] Calculate age in minutes
  - [ ] Return False if age > max_age_minutes
  - [ ] Check saml_assertion.not_on_or_after hasn't passed (assertion expired)
  - [ ] Check current time >= saml_assertion.not_before (assertion not yet valid)
  - [ ] Log timestamp validation failures with specific reason
  - [ ] Example error: "SAML assertion expired. NotOnOrAfter: {timestamp}, Current: {now}"

- [ ] Handle verification errors with actionable messages (AC: 7)
  - [ ] Catch signxml.exceptions.InvalidSignature
    - [ ] Error message: "SAML signature verification failed: {error}. Assertion may be tampered or signed with different certificate."
  - [ ] Catch signxml.exceptions.InvalidDigest
    - [ ] Error message: "SAML digest verification failed: {error}. Assertion content has been modified after signing."
  - [ ] Catch lxml.etree.XMLSyntaxError
    - [ ] Error message: "Invalid XML in signed SAML assertion: {error}. XML may be corrupted."
  - [ ] All verification errors should include guidance on resolution

- [ ] Implement batch signing optimization (AC: 9)
  - [ ] Method: sign_batch(assertions: list[SAMLAssertion]) -> list[SAMLAssertion]
  - [ ] Reuse same XMLSigner instance across all assertions (avoid repeated initialization)
  - [ ] Reuse same certificate and key parsing (done in __init__)
  - [ ] Return list of signed SAMLAssertion objects
  - [ ] Log batch signing summary: "Signed {count} SAML assertions in {duration}ms"
  - [ ] If any signing fails, log error but continue with remaining assertions
  - [ ] Return partial results with successful signatures

- [ ] Update SAMLAssertion dataclass to store signature (AC: 4, 5)
  - [ ] Verify signature field exists in src/ihe_test_util/models/saml.py
  - [ ] signature: str field should store base64-encoded signature value
  - [ ] When signing, extract <ds:SignatureValue> text and store in signature field
  - [ ] signed_xml: Optional[str] could store complete signed XML for convenience
  - [ ] Ensure signature field is populated by sign_assertion() method

- [ ] Integrate with existing SAML modules (AC: 1)
  - [ ] Update src/ihe_test_util/saml/__init__.py to export SAMLSigner and SAMLVerifier
  - [ ] Import CertificateBundle from certificate_manager
  - [ ] Import SAMLAssertion from models
  - [ ] Ensure compatibility with template_loader.py and programmatic_generator.py outputs
  - [ ] Both generators produce canonicalized XML ready for signing
  - [ ] Test signing both template-based and programmatic SAML assertions

- [ ] Create comprehensive unit tests (AC: 10)
  - [ ] Create tests/unit/test_signer.py
  - [ ] Test SAMLSigner initialization with valid certificate bundle
  - [ ] Test SAMLSigner initialization with invalid certificate (should raise error)
  - [ ] Test sign_assertion with valid SAML assertion (template-based)
  - [ ] Test sign_assertion with valid SAML assertion (programmatic)
  - [ ] Test signature algorithm configuration (RSA-SHA256, RSA-SHA512)
  - [ ] Test invalid signature algorithm raises ValueError
  - [ ] Test signing with malformed XML raises appropriate error
  - [ ] Test signing with missing private key raises error
  - [ ] Test signing with expired certificate (should warn but proceed)
  - [ ] Test signed assertion contains <ds:Signature> element
  - [ ] Test signed assertion KeyInfo contains certificate
  - [ ] Test canonicalization method is C14N 1.1
  - [ ] Test signature method is RSA-SHA256 (or configured algorithm)
  - [ ] Test batch signing with 10 assertions
  - [ ] Test batch signing performance (10 assertions < 1 second)
  - [ ] Target 80%+ coverage for signer.py

- [ ] Create verification unit tests (AC: 6, 8, 10)
  - [ ] Create tests/unit/test_verifier.py
  - [ ] Test SAMLVerifier initialization
  - [ ] Test verify_assertion with valid signed assertion returns True
  - [ ] Test verify_assertion with tampered assertion returns False or raises
  - [ ] Test verify_assertion with modified Subject (tampering detection)
  - [ ] Test verify_assertion with modified Issuer (tampering detection)
  - [ ] Test verify_assertion with wrong certificate raises error
  - [ ] Test validate_timestamp_freshness with fresh assertion (< 5 min)
  - [ ] Test validate_timestamp_freshness with old assertion (> 5 min)
  - [ ] Test validate_timestamp_freshness with expired assertion (past NotOnOrAfter)
  - [ ] Test validate_timestamp_freshness with future assertion (before NotBefore)
  - [ ] Test custom max_age_minutes parameter
  - [ ] Test verification error messages are actionable
  - [ ] Target 80%+ coverage for verifier.py

- [ ] Create integration tests (AC: 1, 5, 9)
  - [ ] Create or update tests/integration/test_saml_workflow.py
  - [ ] Test end-to-end: generate programmatic SAML → sign → verify
  - [ ] Test end-to-end: load template SAML → personalize → sign → verify
  - [ ] Test signed SAML from Story 4.2 can be signed and verified
  - [ ] Test signed SAML from Story 4.3 can be signed and verified
  - [ ] Test integration with certificate_manager (Story 4.1)
  - [ ] Test batch signing 100 assertions performance (< 5 seconds)
  - [ ] Test signed SAML is ready for WS-Security embedding (parseable XML)
  - [ ] Test complete workflow: generate → sign → verify → extract signature value

- [ ] Create example demonstrating signing workflow
  - [ ] Create examples/saml_signing_example.py
  - [ ] Demonstrate signing template-based SAML assertion
  - [ ] Demonstrate signing programmatic SAML assertion
  - [ ] Demonstrate signature verification
  - [ ] Demonstrate tampering detection
  - [ ] Demonstrate batch signing
  - [ ] Demonstrate timestamp freshness validation
  - [ ] Include commented examples of error handling
  - [ ] Show when to use signing vs verification

- [ ] Update project documentation
  - [ ] Update docs/saml-guide.md (or create if not exists)
  - [ ] Document XML signing with signxml library
  - [ ] Document supported signature algorithms (RSA-SHA256, RSA-SHA512)
  - [ ] Document canonicalization approach (C14N 1.1)
  - [ ] Add examples for signing and verification
  - [ ] Document error handling and troubleshooting
  - [ ] Add security best practices for certificate handling
  - [ ] Document performance considerations for batch signing
  - [ ] Add troubleshooting section for common signing issues

## Dev Notes

### Previous Story Insights

[Source: Story 4.1 Completion - Certificate Management & Loading]

**Certificate Manager Ready for Signing:**
- Location: `src/ihe_test_util/saml/certificate_manager.py` (production-ready)
- CertificateBundle dataclass includes: certificate (PEM), private_key (PEM), chain, info
- Certificate formats supported: PEM, PKCS12, DER
- Private key loading with password support (PKCS12)
- Certificate validation checks expiration and validity
- 88% test coverage, all tests passing
- Integration point: SAMLSigner will use CertificateBundle for signing

**Certificate Usage Pattern:**
```python
from ihe_test_util.saml.certificate_manager import load_certificate
from pathlib import Path

# Load certificate and private key
cert_bundle = load_certificate(
    Path("certs/saml-signing.p12"),
    password=b"secret"
)

# cert_bundle.certificate -> PEM-encoded certificate string
# cert_bundle.private_key -> PEM-encoded private key string
# Ready for signxml usage
```

[Source: Story 4.2 Completion - Template-Based SAML Generation]

**Template-Based SAML Ready for Signing:**
- Location: `src/ihe_test_util/saml/template_loader.py` (production-ready)
- SAMLAssertion.xml_content is canonicalized XML ready for signing
- Assertion ID follows pattern: _<uuid4> (e.g., _a1b2c3d4e5f6...)
- Timestamps in ISO 8601 format with Z suffix
- 87% test coverage, all tests passing
- Integration point: sign_assertion() will accept SAMLAssertion from template_loader

[Source: Story 4.3 Completion - Programmatic SAML Generation]

**Programmatic SAML Ready for Signing:**
- Location: `src/ihe_test_util/saml/programmatic_generator.py` (production-ready)
- SAMLAssertion.xml_content is canonicalized XML (C14N format)
- Follows SAML 2.0 specification structure
- 100% unit test coverage, 93% integration coverage
- Integration point: sign_assertion() will accept SAMLAssertion from programmatic_generator

**Both SAML Generation Methods:**
- Produce canonicalized XML (lxml.etree with method='c14n')
- Return SAMLAssertion dataclass with xml_content field
- xml_content is ready for XML signature (no additional canonicalization needed)
- Assertion ID is unique and starts with underscore (required for XML signature Reference URI)

[Source: Spike 1.2 - XML Signing Validation]

**Spike Findings - signxml Library Selected:**
- Library: signxml 3.2+ (CONFIRMED for production use)
- Why signxml over python-xmlsec:
  - ✅ Zero compilation (pure Python)
  - ✅ No build tools required (works on Windows immediately)
  - ✅ Pre-built wheels for all platforms
  - ✅ Simple installation: `pip install signxml`
  - ✅ W3C XML Signature 1.1 compliant
  - ✅ Tested against XMLDSig interoperability suite
  - ✅ Supports RSA-SHA256, RSA-SHA512, and modern algorithms
  - ✅ Works with SAML 2.0, XAdES, WS-Security
  - ❌ python-xmlsec requires 2-3 GB Visual C++ Build Tools on Windows

**signxml Signing Pattern from Spike:**
```python
from signxml import XMLSigner, SignatureMethod, DigestAlgorithm
from lxml import etree

# Create signer
signer = XMLSigner(
    signature_algorithm=SignatureMethod.RSA_SHA256,
    digest_algorithm=DigestAlgorithm.SHA256
)

# Sign SAML assertion
signed_assertion = signer.sign(
    assertion_element,  # lxml.etree.Element
    key=private_key_pem,  # PEM string
    cert=certificate_pem  # PEM string
)

# Result: <saml:Assertion> with <ds:Signature> child element
```

**signxml Verification Pattern from Spike:**
```python
from signxml import XMLVerifier

# Create verifier
verifier = XMLVerifier()

# Verify signature
verified_data = verifier.verify(
    signed_assertion,  # lxml.etree.Element
    x509_cert=certificate_pem  # PEM string
)

# Returns verified element if signature valid
# Raises InvalidSignature if tampered
# Raises InvalidDigest if content modified
```

**Spike Validation Results:**
- ✅ SAML assertions signed successfully with RSA-SHA256
- ✅ Signatures verified successfully
- ✅ Tampering detected (modified Subject NameID raised InvalidDigest)
- ✅ Performance adequate (<50ms signing, <30ms verification)
- ✅ Certificate embedding in KeyInfo works correctly
- ✅ Canonicalization (C14N 1.1) applied automatically
- Files: examples/signxml_saml_example.py (working demonstration)

### Tech Stack

[Source: architecture/tech-stack.md]

**XML Signing Library:**

- **signxml 3.2+** - Pure Python W3C XML Signature implementation
  - `XMLSigner` - Sign XML documents with RSA-SHA256/SHA512
  - `XMLVerifier` - Verify XML signatures
  - `SignatureMethod` - Enum for signature algorithms (RSA_SHA256, RSA_SHA512, etc.)
  - `DigestAlgorithm` - Enum for digest algorithms (SHA256, SHA512, etc.)
  - Automatic C14N 1.1 canonicalization
  - Certificate embedding in KeyInfo
  - Tampering detection (InvalidSignature, InvalidDigest exceptions)
  - Zero compilation, works on all platforms
  - W3C XML Signature 1.1 compliant

**Dependencies (already in project):**

- **lxml 5.1+** - XML parsing and canonicalization
  - Parse signed XML: `etree.fromstring()`
  - XML serialization: `etree.tostring()`
  - Used by signxml internally

- **cryptography 41.0+** - Certificate and key handling
  - Used by signxml for cryptographic operations
  - Used by certificate_manager for cert loading

- **Python Built-ins:**
  - `datetime` - Timestamp freshness validation
  - `logging` - All messages (RULE 1)
  - `typing` - Type hints (RULE 7)

**No New Dependencies Required** - signxml already in requirements.txt from Spike 1.2

### File Locations

[Source: architecture/source-tree.md]

**Files to CREATE:**

```
src/ihe_test_util/saml/
├── signer.py                        # XML signing with signxml (NEW)
├── verifier.py                      # Signature verification (NEW)
└── __init__.py                      # Update exports

examples/
├── saml_signing_example.py          # Signing workflow examples (NEW)

tests/unit/
├── test_signer.py                   # Unit tests for signing (NEW)
├── test_verifier.py                 # Unit tests for verification (NEW)

tests/integration/
├── test_saml_workflow.py            # Update with signing tests
```

**Files to REFERENCE (already exist):**

```
src/ihe_test_util/saml/
├── certificate_manager.py           # Certificate loading (Story 4.1, completed)
├── template_loader.py               # Template-based SAML (Story 4.2, completed)
├── programmatic_generator.py        # Programmatic SAML (Story 4.3, completed)

src/ihe_test_util/models/
├── saml.py                          # SAMLAssertion dataclass (already exists)

examples/
├── signxml_saml_example.py          # Spike 1.2 reference implementation

tests/fixtures/
├── test_cert.pem                    # Test certificate (Spike 1.2)
├── test_key.pem                     # Test private key (Spike 1.2)
├── test_cert.p12                    # Test PKCS12 certificate (Spike 1.2)
```

### signxml API Usage

[Source: Spike 1.2 + signxml documentation]

**Signing SAML Assertions:**

```python
from signxml import XMLSigner, SignatureMethod, DigestAlgorithm
from lxml import etree

def sign_assertion(
    assertion_xml: str,
    private_key_pem: str,
    certificate_pem: str,
    algorithm: str = "RSA-SHA256"
) -> str:
    """Sign SAML assertion with XML signature.
    
    Args:
        assertion_xml: Canonicalized SAML assertion XML string
        private_key_pem: PEM-encoded private key
        certificate_pem: PEM-encoded certificate
        algorithm: Signature algorithm (RSA-SHA256, RSA-SHA512)
        
    Returns:
        Signed SAML assertion XML string with <ds:Signature> element
        
    Raises:
        ValueError: If algorithm is unsupported
        signxml.exceptions.InvalidInput: If certificate/key invalid
    """
    # Parse XML
    assertion_element = etree.fromstring(assertion_xml.encode('utf-8'))
    
    # Map algorithm string to SignatureMethod enum
    algorithm_map = {
        "RSA-SHA256": SignatureMethod.RSA_SHA256,
        "RSA-SHA512": SignatureMethod.RSA_SHA512,
    }
    
    if algorithm not in algorithm_map:
        raise ValueError(
            f"Unsupported signature algorithm: {algorithm}. "
            f"Supported: {list(algorithm_map.keys())}"
        )
    
    # Create signer
    signer = XMLSigner(
        signature_algorithm=algorithm_map[algorithm],
        digest_algorithm=DigestAlgorithm.SHA256  # Always SHA256 for digest
    )
    
    # Sign assertion
    signed_element = signer.sign(
        assertion_element,
        key=private_key_pem.encode('utf-8'),
        cert=certificate_pem.encode('utf-8')
    )
    
    # Serialize back to string
    return etree.tostring(signed_element, encoding='unicode')
```

**Verifying Signatures:**

```python
from signxml import XMLVerifier
from signxml.exceptions import InvalidSignature, InvalidDigest
from lxml import etree

def verify_assertion(
    signed_assertion_xml: str,
    certificate_pem: str
) -> bool:
    """Verify XML signature on SAML assertion.
    
    Args:
        signed_assertion_xml: Signed SAML assertion XML
        certificate_pem: PEM-encoded certificate used for signing
        
    Returns:
        True if signature valid, False otherwise
        
    Raises:
        InvalidSignature: Signature verification failed
        InvalidDigest: Content was tampered after signing
    """
    # Parse signed XML
    signed_element = etree.fromstring(signed_assertion_xml.encode('utf-8'))
    
    # Create verifier
    verifier = XMLVerifier()
    
    try:
        # Verify signature
        verified_data = verifier.verify(
            signed_element,
            x509_cert=certificate_pem.encode('utf-8')
        )
        return True
    except InvalidSignature as e:
        logger.warning(f"Signature verification failed: {e}")
        return False
    except InvalidDigest as e:
        logger.warning(f"Content tampering detected: {e}")
        return False
```

### XML Signature Structure

[Source: W3C XML Signature 1.1 + Spike 1.2]

**Expected Signature Element Structure:**

When signxml signs a SAML assertion, it inserts a `<ds:Signature>` element as a child of the `<saml:Assertion>`:

```xml
<saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" 
                ID="_a1b2c3d4..." 
                Version="2.0" 
                IssueInstant="2025-11-11T...">
  <saml:Issuer>https://idp.example.com</saml:Issuer>
  <saml:Subject>...</saml:Subject>
  <saml:Conditions>...</saml:Conditions>
  <saml:AuthnStatement>...</saml:AuthnStatement>
  
  <!-- Signature element added by signxml -->
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
    <ds:SignedInfo>
      <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>
      <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
      <ds:Reference URI="#_a1b2c3d4...">
        <ds:Transforms>
          <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          <ds:Transform Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>
        </ds:Transforms>
        <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue>BASE64_DIGEST_HERE</ds:DigestValue>
      </ds:Reference>
    </ds:SignedInfo>
    <ds:SignatureValue>BASE64_SIGNATURE_HERE</ds:SignatureValue>
    <ds:KeyInfo>
      <ds:X509Data>
        <ds:X509Certificate>BASE64_CERTIFICATE_HERE</ds:X509Certificate>
      </ds:X509Data>
    </ds:KeyInfo>
  </ds:Signature>
</saml:Assertion>
```

**Key Components:**
- `CanonicalizationMethod`: C14N 1.1 (http://www.w3.org/2006/12/xml-c14n11)
- `SignatureMethod`: RSA-SHA256 (http://www.w3.org/2001/04/xmldsig-more#rsa-sha256)
- `DigestMethod`: SHA256 (http://www.w3.org/2001/04/xmlenc#sha256)
- `Reference URI`: Points to assertion ID (#_a1b2c3d4...)
- `Transforms`: Enveloped signature + C14N
- `SignatureValue`: Base64-encoded RSA signature
- `KeyInfo/X509Certificate`: Base64-encoded signing certificate

### Data Models

[Source: architecture/data-models.md]

**SAMLAssertion Dataclass (src/ihe_test_util/models/saml.py):**

```python
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class SAMLGenerationMethod(Enum):
    TEMPLATE = "template"
    PROGRAMMATIC = "programmatic"

@dataclass
class SAMLAssertion:
    assertion_id: str                    # Unique ID (e.g., _a1b2c3d4...)
    issuer: str                          # Issuer identifier
    subject: str                         # Subject (user) identifier
    audience: str                        # Intended audience
    issue_instant: datetime              # Issuance timestamp
    not_before: datetime                 # Validity start
    not_on_or_after: datetime            # Validity end
    xml_content: str                     # Complete SAML XML (unsigned or signed)
    signature: str                       # Base64 signature value (empty until signed)
    certificate_subject: str             # Signing certificate subject DN
    generation_method: SAMLGenerationMethod  # TEMPLATE or PROGRAMMATIC
```

**Usage in SAMLSigner:**

```python
def sign_assertion(self, saml_assertion: SAMLAssertion) -> SAMLAssertion:
    # Parse xml_content
    assertion_element = etree.fromstring(saml_assertion.xml_content.encode('utf-8'))
    
    # Sign with signxml
    signed_element = self.signer.sign(
        assertion_element,
        key=self.private_key,
        cert=self.certificate
    )
    
    # Extract signature value
    ns = {'ds': 'http://www.w3.org/2000/09/xmldsig#'}
    sig_value = signed_element.find('.//ds:SignatureValue', ns).text
    
    # Serialize signed XML
    signed_xml = etree.tostring(signed_element, encoding='unicode')
    
    # Return new SAMLAssertion with signature
    return SAMLAssertion(
        assertion_id=saml_assertion.assertion_id,
        issuer=saml_assertion.issuer,
        subject=saml_assertion.subject,
        audience=saml_assertion.audience,
        issue_instant=saml_assertion.issue_instant,
        not_before=saml_assertion.not_before,
        not_on_or_after=saml_assertion.not_on_or_after,
        xml_content=signed_xml,  # Updated with signature
        signature=sig_value,     # Extracted signature value
        certificate_subject=saml_assertion.certificate_subject,
        generation_method=saml_assertion.generation_method
    )
```

### Coding Standards

[Source: architecture/coding-standards.md]

**CRITICAL RULES - MUST FOLLOW:**

1. **RULE 1: Never use print() statements**
   - Use logging module for all messages
   - Example: `logger.info("Signed SAML assertion {assertion_id}")` not `print("Signed...")`

2. **RULE 5: Exceptions must include actionable context**
   - Error messages explain what failed and suggest fixes
   - Example: `raise ValueError(f"Unsupported signature algorithm: {alg}. Supported: RSA-SHA256, RSA-SHA512")`

3. **RULE 6: No bare except clauses**
   - Always catch specific exceptions
   - Example: `except InvalidSignature` not `except:`

4. **RULE 7: Type hints are mandatory**
   - All functions must have complete type hints
   - Example: `def sign_assertion(self, saml_assertion: SAMLAssertion) -> SAMLAssertion:`

**Google-Style Docstrings:**

```python
def sign_assertion(self, saml_assertion: SAMLAssertion) -> SAMLAssertion:
    """Sign SAML assertion with XML digital signature.
    
    Applies W3C XML Signature with RSA-SHA256 algorithm to the provided
    SAML assertion. The signature is embedded as a child element of the
    assertion and includes the signing certificate in KeyInfo.
    
    Args:
        saml_assertion: Unsigned SAML assertion to sign
        
    Returns:
        New SAMLAssertion with signature embedded in xml_content and
        signature field populated with base64 signature value
        
    Raises:
        ValueError: If SAML assertion has invalid XML structure
        signxml.exceptions.InvalidInput: If certificate or key is invalid
        
    Example:
        >>> signer = SAMLSigner(cert_bundle)
        >>> unsigned_assertion = generator.generate(...)
        >>> signed_assertion = signer.sign_assertion(unsigned_assertion)
        >>> assert signed_assertion.signature != ""
        >>> assert "<ds:Signature" in signed_assertion.xml_content
    """
```

### Testing

[Source: architecture/test-strategy-and-standards.md]

**Test File Locations:**
- **Unit Tests:** `tests/unit/test_signer.py` and `tests/unit/test_verifier.py`
- **Integration Tests:** `tests/integration/test_saml_workflow.py` (update existing)

**Test Coverage Goal:**
- **Minimum:** 75% (CI requirement)
- **Target:** 80%+ for signer.py and verifier.py
- **Critical paths:** 100% (signing, verification, error handling)

**Testing Framework:** pytest 7.4+

**Test Fixtures:**
- Use existing certificates from `tests/fixtures/` (generated in Spike 1.2)
- test_cert.pem / test_key.pem (PEM format)
- test_cert.p12 (PKCS12 format)
- Certificate chain in tests/fixtures/cert_chain/

**Testing Approach:**

**Unit Tests (with pytest):**

```python
import pytest
from lxml import etree
from signxml.exceptions import InvalidSignature, InvalidDigest
from ihe_test_util.saml.signer import SAMLSigner
from ihe_test_util.saml.verifier import SAMLVerifier
from ihe_test_util.saml.certificate_manager import load_certificate
from ihe_test_util.saml.programmatic_generator import SAMLProgrammaticGenerator
from pathlib import Path

@pytest.fixture
def cert_bundle():
    """Load test certificate bundle."""
    return load_certificate(Path("tests/fixtures/test_cert.pem"))

@pytest.fixture
def unsigned_assertion():
    """Generate unsigned SAML assertion for testing."""
    generator = SAMLProgrammaticGenerator()
    return generator.generate(
        subject="test-user@example.com",
        issuer="https://test-idp.example.com",
        audience="https://test-sp.example.com"
    )

def test_signer_initialization_success(cert_bundle):
    """Test SAMLSigner initializes with valid certificate."""
    signer = SAMLSigner(cert_bundle)
    assert signer is not None

def test_signer_initialization_invalid_algorithm(cert_bundle):
    """Test SAMLSigner rejects invalid signature algorithm."""
    with pytest.raises(ValueError, match="Unsupported signature algorithm"):
        SAMLSigner(cert_bundle, signature_algorithm="MD5")  # Invalid

def test_sign_assertion_success(cert_bundle, unsigned_assertion):
    """Test signing SAML assertion adds signature element."""
    signer = SAMLSigner(cert_bundle)
    signed_assertion = signer.sign_assertion(unsigned_assertion)
    
    # Verify signature element added
    assert "<ds:Signature" in signed_assertion.xml_content
    assert signed_assertion.signature != ""
    assert signed_assertion.assertion_id == unsigned_assertion.assertion_id
    
    # Parse and verify structure
    tree = etree.fromstring(signed_assertion.xml_content.encode('utf-8'))
    ns = {'ds': 'http://www.w3.org/2000/09/xmldsig#'}
    sig_element = tree.find('.//ds:Signature', ns)
    assert sig_element is not None

def test_verify_assertion_success(cert_bundle, unsigned_assertion):
    """Test verifying valid signed assertion."""
    signer = SAMLSigner(cert_bundle)
    signed_assertion = signer.sign_assertion(unsigned_assertion)
    
    verifier = SAMLVerifier(cert_bundle)
    result = verifier.verify_assertion(signed_assertion)
    
    assert result is True

def test_verify_assertion_tampered_data(cert_bundle, unsigned_assertion):
    """Test verification fails for tampered assertion."""
    signer = SAMLSigner(cert_bundle)
    signed_assertion = signer.sign_assertion(unsigned_assertion)
    
    # Tamper with signed XML
    tampered_xml = signed_assertion.xml_content.replace(
        unsigned_assertion.subject,
        "TAMPERED-USER"
    )
    
    from dataclasses import replace
    tampered_assertion = replace(signed_assertion, xml_content=tampered_xml)
    
    verifier = SAMLVerifier(cert_bundle)
    
    with pytest.raises(InvalidDigest):
        verifier.verify_assertion(tampered_assertion)

def test_batch_signing_performance(cert_bundle):
    """Test batch signing 10 assertions completes in < 1 second."""
    import time
    generator = SAMLProgrammaticGenerator()
    assertions = [
        generator.generate(
            subject=f"user{i}@example.com",
            issuer="https://idp.example.com",
            audience="https://sp.example.com"
        )
        for i in range(10)
    ]
    
    signer = SAMLSigner(cert_bundle)
    start = time.time()
    signed_assertions = signer.sign_batch(assertions)
    duration = time.time() - start
    
    assert len(signed_assertions) == 10
    assert duration < 1.0  # Should complete in < 1 second
    assert all(a.signature != "" for a in signed_assertions)
```

**Integration Tests:**

```python
def test_end_to_end_programmatic_saml_signing():
    """Test complete workflow: generate → sign → verify."""
    from ihe_test_util.saml.programmatic_generator import SAMLProgrammaticGenerator
    from ihe_test_util.saml.signer import SAMLSigner
    from ihe_test_util.saml.verifier import SAMLVerifier
    from ihe_test_util.saml.certificate_manager import load_certificate
    
    # Generate SAML assertion
    generator = SAMLProgrammaticGenerator()
    assertion = generator.generate(
        subject="patient@hospital.org",
        issuer="https://idp.hospital.org",
        audience="https://xds.regional-hie.org"
    )
    
    # Sign assertion
    cert_bundle = load_certificate(Path("tests/fixtures/test_cert.pem"))
    signer = SAMLSigner(cert_bundle)
    signed_assertion = signer.sign_assertion(assertion)
    
    # Verify signature
    verifier = SAMLVerifier(cert_bundle)
    is_valid = verifier.verify_assertion(signed_assertion)
    
    assert is_valid is True
    assert "<ds:Signature" in signed_assertion.xml_content
```

### Integration Points

**Upstream Dependencies:**
- Story 4.1: Certificate Management (completed) - provides CertificateBundle
- Story 4.2: Template-Based SAML (completed) - provides SAMLAssertion with canonicalized XML
- Story 4.3: Programmatic SAML (completed) - provides SAMLAssertion with canonicalized XML
- Spike 1.2: XML Signing Validation (completed) - validated signxml library

**Downstream Usage:**
- Story 4.5: WS-Security Header Construction (embeds signed SAML in SOAP headers)
- Story 5.x: PIX Add Transaction (uses signed SAML for authentication)
- Story 6.x: ITI-41 Transaction (uses signed SAML for authentication)

**No Circular Dependencies** - XML signing is independent

### Security Considerations

[Source: Spike 1.2 + W3C XML Signature Best Practices]

**Signature Algorithm:**
- Default: RSA-SHA256 (secure and widely supported)
- Alternative: RSA-SHA512 (more secure but larger signatures)
- Do NOT support: MD5, SHA1 (deprecated, insecure)

**Canonicalization:**
- C14N 1.1 (http://www.w3.org/2006/12/xml-c14n11)
- Prevents whitespace and namespace prefix attacks
- Applied automatically by signxml

**Certificate Validation:**
- Verify certificate expiration before signing (warn if near expiry)
- Validate certificate subject matches expected issuer
- Support certificate chains if provided

**Timestamp Validation:**
- Verify SAML assertion timestamps (NotBefore, NotOnOrAfter)
- Reject assertions older than max_age_minutes (default 5)
- Log all timestamp validation failures

**Private Key Security:**
- Never log private keys (already handled by certificate_manager)
- Private keys only used for signing, never exposed
- Private keys stay in memory, never written to disk

**Error Messages:**
- Never include full certificate or key in error messages
- Include actionable guidance for resolution
- Log sensitive operations (signing, verification) without exposing secrets

### Performance Targets

[Source: Spike 1.2 findings]

**Signing Performance:**
- Single assertion: < 50ms
- Batch of 10: < 1 second
- Batch of 100: < 5 seconds

**Verification Performance:**
- Single assertion: < 30ms
- Batch of 10: < 500ms

**Optimization Strategies:**
- Reuse XMLSigner instance for batch operations
- Parse certificate/key once in __init__, reuse for all signatures
- Avoid repeated lxml parsing where possible

### Example Usage

**Signing SAML Assertion:**

```python
from pathlib import Path
from ihe_test_util.saml.certificate_manager import load_certificate
from ihe_test_util.saml.programmatic_generator import SAMLProgrammaticGenerator
from ihe_test_util.saml.signer import SAMLSigner

# Load certificate
cert_bundle = load_certificate(
    Path("certs/saml-signing.p12"),
    password=b"secret"
)

# Generate SAML assertion
generator = SAMLProgrammaticGenerator()
assertion = generator.generate(
    subject="dr.smith@hospital.org",
    issuer="https://idp.hospital.org",
    audience="https://xds.regional-hie.org"
)

# Sign assertion
signer = SAMLSigner(cert_bundle, signature_algorithm="RSA-SHA256")
signed_assertion = signer.sign_assertion(assertion)

print(f"Signed SAML assertion: {signed_assertion.assertion_id}")
print(f"Signature: {signed_assertion.signature[:50]}...")
```

**Verifying Signed SAML:**

```python
from ihe_test_util.saml.verifier import SAMLVerifier

# Verify signature
verifier = SAMLVerifier(cert_bundle)
is_valid = verifier.verify_assertion(signed_assertion)

if is_valid:
    print("✅ Signature verified successfully")
else:
    print("❌ Signature verification failed")

# Validate timestamp freshness
is_fresh = verifier.validate_timestamp_freshness(
    signed_assertion,
    max_age_minutes=5
)

if is_fresh:
    print("✅ SAML assertion is fresh")
else:
    print("⚠️ SAML assertion is expired or not yet valid")
```

**Batch Signing:**

```python
# Generate multiple assertions
assertions = [
    generator.generate(
        subject=f"user{i}@hospital.org",
        issuer="https://idp.hospital.org",
        audience="https://xds.regional-hie.org"
    )
    for i in range(100)
]

# Sign batch (optimized)
signer = SAMLSigner(cert_bundle)
signed_assertions = signer.sign_batch(assertions)

print(f"Signed {len(signed_assertions)} SAML assertions")
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-11 | 1.0 | Initial story creation for Epic 4 | Scrum Master (Bob) |
| 2025-11-11 | 1.1 | PO validation complete - APPROVED for implementation - 10/10 readiness score, zero issues found | Product Owner (Sarah) |

## QA Results

### Review Date: 2025-11-12

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment:** Excellent implementation with production-ready quality. The XML signature implementation demonstrates comprehensive understanding of W3C XML Signature standards, proper use of the signxml library, and excellent software engineering practices.

**Implementation Highlights:**
- **signer.py**: Clean, well-structured SAMLSigner class with proper initialization, validation, and error handling. Batch signing optimization implemented correctly with XMLSigner instance reuse.
- **verifier.py**: Robust SAMLVerifier class with flexible certificate handling (bundle, parameter, or KeyInfo extraction). Comprehensive timestamp freshness validation with detailed logging.
- **Architecture**: Proper separation of concerns between signing and verification. Excellent integration with existing SAML infrastructure (certificate_manager, programmatic_generator, template_loader).
- **Error Handling**: All error paths include actionable context per RULE 5. No bare except clauses (RULE 6 compliance).
- **Type Safety**: Complete type hints throughout (RULE 7 compliance).
- **Documentation**: Comprehensive Google-style docstrings with usage examples in all public methods.

### Test Execution Results

**Unit Tests - signer.py:**
- Command: `python -m pytest tests/unit/test_signer.py -v`
- Result: **18/18 PASSED** ✅
- Coverage: **89%** (65 statements, 7 missed)
- Performance: All tests completed in 6.56s

**Test Coverage Breakdown (signer.py):**
- Missed lines: 172, 204-213 (error handling branches, acceptable)
- Critical paths: 100% coverage (signing, batch signing, initialization)
- Error scenarios: Comprehensive coverage with deliberate edge case testing

**Unit Tests - verifier.py:**
- Command: `python -m pytest tests/unit/test_verifier.py -v`
- Result: **22/22 PASSED** ✅
- Coverage: **89%** (81 statements, 9 missed)
- Performance: All tests completed in 3.48s
- Warning: 1 deprecation warning about test certificate serial number (test fixture issue, not production code)

**Test Coverage Breakdown (verifier.py):**
- Missed lines: 156-160, 174-179, 299-303 (error handling branches, acceptable)
- Critical paths: 100% coverage (verification, timestamp validation, tampering detection)
- Error scenarios: Comprehensive coverage including tampered assertions

**Integration Tests:**
- Command: `python -m pytest tests/integration/test_saml_workflow.py -v`
- Result: **9/9 PASSED**, 1 SKIPPED ✅
- Skipped: test_saml_template_with_certificate_workflow (placeholder for Story 4.5)
- Performance: All tests completed in 2.60s

**Performance Validation:**
- ✅ Batch signing 10 assertions: < 1 second (AC 9 met)
- ✅ Single assertion signing: < 50ms
- ✅ Signature verification: < 30ms

### Compliance Check

- **Coding Standards:** ✅ Full compliance
  - RULE 1 (No print statements): ✅ All logging via logging module
  - RULE 5 (Actionable exceptions): ✅ All error messages include context and guidance
  - RULE 6 (No bare except): ✅ All exceptions specifically caught
  - RULE 7 (Type hints): ✅ Complete type annotations throughout
- **Project Structure:** ✅ Files in correct locations per architecture
- **Testing Strategy:** ✅ 89% coverage exceeds 80% target
- **All ACs Met:** ✅ 10/10 acceptance criteria validated

### Acceptance Criteria Validation

1. ✅ **XML signing using signxml library** - Implemented with XMLSigner, RSA-SHA256 default
2. ✅ **Signature algorithm configurable** - Supports RSA-SHA256 and RSA-SHA512 with validation
3. ✅ **XML canonicalization (C14N)** - C14N 1.1 applied automatically by signxml
4. ✅ **Signature includes KeyInfo** - X509Certificate embedded in signature
5. ✅ **Signed SAML validates against spec** - W3C XML Signature 1.1 compliant
6. ✅ **Signature verification function** - SAMLVerifier with verify_assertion() method
7. ✅ **Clear error messages** - All error paths include actionable guidance
8. ✅ **Timestamp freshness validated** - validate_timestamp_freshness() with configurable max_age
9. ✅ **Performance optimization** - Batch signing reuses XMLSigner, meets < 1s for 10 assertions
10. ✅ **Unit tests comprehensive** - 40 unit tests total, 89% coverage on both modules

### Requirements Traceability

| AC | Requirement | Implementation | Tests | Status |
|----|-------------|----------------|-------|--------|
| 1 | signxml library | SAMLSigner uses XMLSigner | test_sign_assertion_success | ✅ |
| 2 | Configurable algorithm | signature_algorithm parameter | test_signer_initialization_custom_algorithm | ✅ |
| 3 | C14N canonicalization | Automatic via signxml | test_sign_assertion_signature_structure | ✅ |
| 4 | KeyInfo with cert | X509Certificate in signature | test_sign_assertion_signature_structure | ✅ |
| 5 | XML signature validation | W3C compliant signatures | test_verify_assertion_success | ✅ |
| 6 | Verification function | SAMLVerifier.verify_assertion() | test_verify_assertion_* (9 tests) | ✅ |
| 7 | Clear error messages | Actionable exceptions | test_error_messages_actionable | ✅ |
| 8 | Timestamp validation | validate_timestamp_freshness() | test_validate_timestamp_* (5 tests) | ✅ |
| 9 | Batch optimization | sign_batch() method | test_sign_batch_performance | ✅ |
| 10 | Comprehensive tests | 40 unit tests, 9 integration | All test files | ✅ |

### Security Review

**Strengths:**
- ✅ Private keys properly handled via cryptography library serialization
- ✅ No private key exposure in logs or error messages
- ✅ Certificate validation during SAMLSigner initialization
- ✅ Secure algorithms enforced (RSA-SHA256/SHA512, no MD5/SHA1)
- ✅ Tampering detection via InvalidSignature and digest verification
- ✅ Timestamp freshness validation prevents replay attacks

**Security Testing:**
- ✅ Tampering detection validated (test_verify_assertion_tampered_subject/issuer)
- ✅ Invalid certificate rejection tested
- ✅ Wrong certificate detection tested
- ✅ Expired/future assertion rejection tested

**No Security Concerns Identified**

### Performance Considerations

**Performance Metrics (Actual):**
- Single assertion signing: ~36ms (target: < 50ms) ✅
- Batch of 10 assertions: ~360ms (target: < 1 second) ✅
- Single verification: ~16ms (target: < 30ms) ✅

**Optimization Techniques Validated:**
- ✅ XMLSigner instance reuse in batch operations
- ✅ Certificate/key parsed once in __init__
- ✅ No redundant lxml parsing

### Non-Functional Requirements Assessment

**Security:** ✅ PASS
- RSA-SHA256/SHA512 algorithms
- C14N prevents manipulation
- Tampering detection functional
- No key exposure

**Performance:** ✅ PASS
- Meets all performance targets
- Batch optimization effective
- No performance bottlenecks

**Reliability:** ✅ PASS
- Comprehensive error handling
- Graceful degradation in batch signing
- Proper logging for debugging

**Maintainability:** ✅ PASS
- Clear code structure
- Excellent documentation
- Type safety throughout
- Testability designed-in

### Improvements Identified

**None Required for Production Release**

All code meets production quality standards. Minor uncovered branches (11% of code) represent uncommon error conditions that are appropriately handled.

**Optional Future Enhancements (Low Priority):**
- Consider adding support for RSA-SHA384 if needed for specific IHE profiles
- Add metrics/telemetry for signature operations if monitoring requirements emerge
- Consider certificate chain validation if multi-level PKI is required

### Technical Debt Assessment

**Zero Technical Debt Identified**

This implementation represents clean, production-ready code with no shortcuts, workarounds, or "TODO" items requiring future attention.

### Integration Validation

**Upstream Integration:**
- ✅ Certificate Manager (Story 4.1): CertificateBundle integration verified
- ✅ Template-Based SAML (Story 4.2): Template assertions signed successfully
- ✅ Programmatic SAML (Story 4.3): Programmatic assertions signed successfully
- ✅ Spike 1.2 findings: signxml library validated as expected

**Downstream Readiness:**
- ✅ Signed assertions ready for WS-Security embedding (Story 4.5)
- ✅ Signature format compatible with IHE PIX Add requirements
- ✅ Signature format compatible with IHE ITI-41 requirements

### Files Modified During Review

**No files modified during review** - Implementation quality did not require refactoring or corrections.

### Gate Status

**Gate:** PASS → docs/qa/gates/4.4-xml-signature-implementation.yml

**Quality Score:** 95/100
- Base: 100
- Deductions: -5 (minor: 11% uncovered error branches, acceptable)

**Evidence Summary:**
- 40/40 unit tests passed
- 9/9 integration tests passed
- Coverage: signer.py 89%, verifier.py 89%
- All 10 acceptance criteria validated
- Performance targets exceeded
- Zero security concerns
- Production-ready quality

### Recommended Status

**✅ Ready for Done**

**Rationale:**
- All acceptance criteria met with evidence
- Test coverage exceeds 80% target (89% achieved)
- All tests passing (40 unit + 9 integration)
- Zero blocking issues identified
- Production-ready code quality
- Comprehensive documentation
- Performance targets met
- Security requirements satisfied

**No changes required. Story is complete and ready for production deployment.**
