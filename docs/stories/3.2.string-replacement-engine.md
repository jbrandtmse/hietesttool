# Story 3.2: String Replacement Engine

## Status
Done

## Story

**As a** developer,
**I want** a string replacement engine for personalizing XML templates,
**so that** I can generate patient-specific documents from demographics.

## Acceptance Criteria

1. Replacement engine accepts template and dictionary of field values
2. All placeholder instances (`{{field_name}}`) replaced with corresponding values
3. Missing values in dictionary trigger clear error or use configurable default
4. Special character escaping for XML (e.g., &, <, >, quotes)
5. Date formatting applied automatically for date fields (configurable format)
6. OID values properly inserted for patient identifiers
7. Whitespace and indentation preserved from original template
8. Support for nested placeholders and conditional sections
9. Replacement operation efficient for batch processing (100+ patients)
10. Unit tests verify replacement accuracy, escaping, error handling, performance

## Tasks / Subtasks

- [x] Create string replacement personalizer module (AC: 1, 2, 7)
  - [x] Create `TemplatePersonalizer` class in `src/ihe_test_util/template_engine/personalizer.py`
  - [x] Implement `personalize(template: str, values: dict[str, Any]) -> str` method
  - [x] Use regex pattern `{{(\w+)}}` to find and replace all placeholders
  - [x] Preserve whitespace and indentation from original template (AC: 7)
  - [x] Add type hints for all function signatures (Coding Standard RULE 7)
  - [x] Add Google-style docstrings for all public methods
  - [x] Use logging module for debug/info messages (Coding Standard RULE 1)

- [x] Implement missing value handling (AC: 3)
  - [x] Add `MissingValueStrategy` enum: ERROR, USE_DEFAULT, USE_EMPTY
  - [x] Add `default_value_map: dict[str, str]` parameter to personalizer
  - [x] Raise `MissingPlaceholderValueError` when missing and strategy is ERROR
  - [x] Use default value from map when strategy is USE_DEFAULT
  - [x] Use empty string when strategy is USE_EMPTY
  - [x] Include actionable error messages listing missing fields (Coding Standard RULE 5)

- [x] Implement XML special character escaping (AC: 4)
  - [x] Create `escape_xml_value(value: str) -> str` function
  - [x] Escape `&` → `&amp;`
  - [x] Escape `<` → `&lt;`
  - [x] Escape `>` → `&gt;`
  - [x] Escape `"` → `&quot;`
  - [x] Escape `'` → `&apos;`
  - [x] Apply escaping to all string values before replacement
  - [x] Add unit tests for all escape scenarios

- [x] Implement date formatting (AC: 5)
  - [x] Create `format_date_value(value: date, format_str: str) -> str` function
  - [x] Support HL7 format: `YYYYMMDD` (default for CCDs)
  - [x] Support ISO format: `YYYY-MM-DD`
  - [x] Support display format: `MM/DD/YYYY`
  - [x] Use `python-dateutil` for date parsing if input is string
  - [x] Auto-detect date/datetime types and apply formatting
  - [x] Make format configurable via `date_format` parameter

- [x] Implement OID value handling (AC: 6)
  - [x] Validate OID format using regex: `^\d+(\.\d+)*$`
  - [x] Create `validate_oid(oid: str) -> bool` utility function
  - [x] Log warning if OID format is invalid but don't fail (permissive)
  - [x] Insert OID values without modification (no escaping needed)

- [x] Implement nested placeholder support (AC: 8)
  - [x] Support simple nesting: `{{outer_{{inner}}}}`
  - [x] Process inner placeholders first (recursive replacement)
  - [x] Add `max_nesting_depth` parameter (default: 3) to prevent infinite loops
  - [x] Raise `MaxNestingDepthError` if depth exceeded
  - [x] Document nesting behavior in docstrings

- [x] Optimize for batch processing (AC: 9)
  - [x] Compile regex pattern once and reuse (class-level constant)
  - [x] Avoid re-parsing template for each personalization
  - [x] Use string replacement instead of XML parsing for performance
  - [x] Target: <100ms per personalization for typical CCD template
  - [x] Add benchmark tests to verify performance

- [x] Create comprehensive unit tests (AC: 10)
  - [x] Create `tests/unit/test_personalizer.py`
  - [x] Test basic placeholder replacement with simple values
  - [x] Test XML special character escaping
  - [x] Test date formatting with multiple formats
  - [x] Test OID value insertion
  - [x] Test missing value handling (all strategies)
  - [x] Test nested placeholder replacement
  - [x] Test whitespace preservation
  - [x] Test empty template and empty values dict
  - [x] Test very large templates (performance)
  - [x] Test concurrent personalization (thread safety)
  - [x] Follow AAA pattern (Arrange, Act, Assert)
  - [x] Target 80%+ code coverage for personalizer.py

- [x] Integration with TemplateLoader (Story 3.1)
  - [x] Update `template_engine/__init__.py` to export `TemplatePersonalizer`
  - [x] Create integration test combining loader + personalizer
  - [x] Test: Load template → Personalize → Validate result as well-formed XML
  - [x] Verify cached templates work correctly with personalizer

- [x] Add custom exceptions (AC: 3)
  - [x] Add `MissingPlaceholderValueError` to `utils/exceptions.py`
  - [x] Add `MaxNestingDepthError` to `utils/exceptions.py`
  - [x] Add `InvalidOIDFormatError` to `utils/exceptions.py` (optional, for strict mode)
  - [x] All exceptions inherit from `TemplateError` base class (from Story 3.1)

## Dev Notes

### Previous Story Insights

[Source: Story 3.1 Completion]

**Story 3.1 - XML Template Loader & Validator:**
- Created `template_engine` module with loader and validators
- `TemplateLoader` class loads templates from files/strings with caching
- `extract_placeholders(xml_content: str) -> set[str]` function finds all `{{field_name}}` placeholders
- `validate_xml(xml_content: str)` validates well-formed XML using lxml
- Required CCD placeholders defined in `REQUIRED_CCD_FIELDS` constant
- Template caching implemented for batch operations
- All exceptions inherit from `TemplateError` base class

**Integration Points:**
- This story (3.2) uses `TemplateLoader` to load templates before personalization
- This story uses `extract_placeholders()` to verify all placeholders have values
- Both stories share same placeholder syntax: `{{field_name}}`
- Both stories use same exception hierarchy (`TemplateError` base)

**Relevance to Story 3.2:**
- Personalizer receives loaded template string from TemplateLoader
- Can use `extract_placeholders()` to check which values are needed
- Should validate personalized output is well-formed XML using `validate_xml()`
- Cache considerations: personalizer operates on strings, doesn't need caching

### Tech Stack

[Source: architecture/tech-stack.md]

**Core Python Libraries:**
- **Python 3.10+** - Modern features (type hints, dataclasses)
- **re** (built-in) - Regular expressions for placeholder replacement
- **html.escape** (built-in) - XML/HTML character escaping
- **python-dateutil 2.8+** - Date parsing and formatting
- **datetime** (built-in) - Date/time handling
- **typing** (built-in) - Type hints (dict, Any, Optional)

**Already Available from Story 3.1:**
- **lxml 5.1+** - XML validation after personalization
- **logging** (built-in) - Structured logging
- **pathlib** (built-in) - Path handling (if needed)

**Testing:**
- **pytest 7.4+** - Testing framework
- **pytest-mock 3.12+** - Mocking library
- **pytest-cov 4.1+** - Coverage reporting
- **pytest-benchmark** (optional) - Performance benchmarking

**No New Dependencies Required** - All necessary libraries already in tech stack or built-in.

### File Locations

[Source: architecture/source-tree.md]

**Files to CREATE:**

```
src/ihe_test_util/template_engine/
├── personalizer.py                # TemplatePersonalizer class (NEW)
```

**Files to UPDATE:**

```
src/ihe_test_util/template_engine/
├── __init__.py                    # Add TemplatePersonalizer export

src/ihe_test_util/utils/
└── exceptions.py                  # Add personalizer-specific exceptions
```

**Test Files to CREATE:**

```
tests/unit/
└── test_personalizer.py           # Unit tests for personalizer (NEW)

tests/integration/
└── test_template_workflow.py      # Loader → Personalizer integration (NEW)
```

**Files to REFERENCE (already exist from Story 3.1):**

```
src/ihe_test_util/template_engine/loader.py      # TemplateLoader class
src/ihe_test_util/template_engine/validators.py  # extract_placeholders(), validate_xml()
src/ihe_test_util/utils/exceptions.py            # TemplateError base class
src/ihe_test_util/models/patient.py              # PatientDemographics fields
tests/fixtures/test_ccd_template.xml             # Test template with placeholders
```

### Data Models

[Source: architecture/data-models.md]

**PatientDemographics Fields (Source for Replacement Values):**

From `src/ihe_test_util/models/patient.py`:

```python
@dataclass
class PatientDemographics:
    # REQUIRED fields (must be in values dict):
    patient_id: str
    patient_id_oid: str
    first_name: str
    last_name: str
    dob: date                        # Date type - needs formatting
    gender: str                      # M, F, O, U
    
    # OPTIONAL fields (may be missing):
    mrn: Optional[str] = None
    ssn: Optional[str] = None
    address: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None
```

**Value Type Handling:**

| Field Type | Example Value | Formatting Required |
|------------|---------------|---------------------|
| `str` | `"John"` | XML escaping only |
| `date` | `date(1980, 1, 15)` | Convert to HL7: `19800115` |
| `datetime` | `datetime.now()` | Convert to HL7: `20231115120000` |
| `Optional[str]` | `None` or `"value"` | Use MissingValueStrategy |

**Placeholder → Field Mapping:**

Placeholder format must match PatientDemographics attribute names exactly:
- `{{patient_id}}` → `patient.patient_id`
- `{{first_name}}` → `patient.first_name`
- `{{dob}}` → `patient.dob` (formatted as YYYYMMDD)
- `{{patient_id_oid}}` → `patient.patient_id_oid`
- etc.

**Dictionary Construction:**

When personalizing, caller provides dict created from dataclass:

```python
from dataclasses import asdict

patient = PatientDemographics(...)
values_dict = asdict(patient)  # Converts dataclass to dict
# values_dict = {"patient_id": "...", "first_name": "...", "dob": date(...), ...}

personalizer = TemplatePersonalizer()
result = personalizer.personalize(template, values_dict)
```

### Coding Standards

[Source: architecture/coding-standards.md]

**CRITICAL RULES - MUST FOLLOW:**

1. **RULE 1: Never use print() statements**
   - Always use logging module
   - Example: `logger.debug(f"Replacing {len(placeholders)} placeholders")` NOT `print()`

2. **RULE 5: Exceptions must include actionable context**
   - Error messages explain what failed AND suggest fixes
   - Example: `raise MissingPlaceholderValueError(f"Missing required values: {missing}. Check PatientDemographics has all required fields.")`

3. **RULE 6: No bare except clauses**
   - Always catch specific exceptions
   - Example: `except KeyError as e:` NOT `except:`

4. **RULE 7: Type hints are mandatory**
   - All function signatures must have complete type hints
   - Example: `def personalize(template: str, values: dict[str, Any]) -> str:`

**Naming Conventions:**

| Element | Convention | Example |
|---------|-----------|---------|
| Classes | PascalCase | `TemplatePersonalizer` |
| Functions | snake_case | `escape_xml_value()` |
| Constants | UPPER_SNAKE_CASE | `PLACEHOLDER_PATTERN` |
| Enums | PascalCase class, UPPER_SNAKE_CASE values | `MissingValueStrategy.USE_DEFAULT` |

**Docstring Format:**

Google-style docstrings required:

```python
def personalize(template: str, values: dict[str, Any], **options) -> str:
    """Personalize XML template by replacing placeholders with values.
    
    Args:
        template: XML template string with {{field_name}} placeholders
        values: Dictionary mapping field names to values
        **options: Additional options (date_format, missing_value_strategy, etc.)
        
    Returns:
        Personalized XML string with all placeholders replaced
        
    Raises:
        MissingPlaceholderValueError: If required placeholder has no value
        MaxNestingDepthError: If nested placeholders exceed max depth
    """
```

**Import Organization:**

```python
# Standard library
import re
from datetime import date, datetime
from enum import Enum
from html import escape
from typing import Any, Optional

# Third-party
from dateutil.parser import parse as parse_date

# Local
from ihe_test_util.template_engine.validators import extract_placeholders, validate_xml
from ihe_test_util.utils.exceptions import (
    MissingPlaceholderValueError,
    MaxNestingDepthError
)
from ihe_test_util.logging_audit.logger import get_logger
```

### Testing Standards

[Source: architecture/test-strategy-and-standards.md]

**Unit Test Requirements:**

- **Framework:** pytest 7.4+
- **File:** `tests/unit/test_personalizer.py`
- **Coverage Goal:** 80%+ for personalizer.py
- **Pattern:** AAA (Arrange, Act, Assert)

**Test Organization:**

```python
# tests/unit/test_personalizer.py

import pytest
from datetime import date, datetime
from ihe_test_util.template_engine.personalizer import (
    TemplatePersonalizer,
    MissingValueStrategy,
    escape_xml_value,
    format_date_value
)
from ihe_test_util.utils.exceptions import (
    MissingPlaceholderValueError,
    MaxNestingDepthError
)

class TestTemplatePersonalizer:
    """Test suite for TemplatePersonalizer class."""
    
    def test_personalize_simple_placeholders(self):
        # Arrange
        template = "<patient><name>{{first_name}} {{last_name}}</name></patient>"
        values = {"first_name": "John", "last_name": "Doe"}
        personalizer = TemplatePersonalizer()
        
        # Act
        result = personalizer.personalize(template, values)
        
        # Assert
        assert "<name>John Doe</name>" in result
        assert "{{" not in result  # No placeholders remaining
    
    # ... more tests

class TestXMLEscaping:
    """Test suite for XML special character escaping."""
    
    def test_escape_xml_value_ampersand(self):
        assert escape_xml_value("Fish & Chips") == "Fish &amp; Chips"
    
    # ... more tests

class TestDateFormatting:
    """Test suite for date formatting."""
    
    def test_format_date_hl7_format(self):
        d = date(1980, 1, 15)
        assert format_date_value(d, "HL7") == "19800115"
    
    # ... more tests
```

**Test Coverage Areas:**

- ✅ Basic placeholder replacement (simple strings)
- ✅ XML special character escaping (all 5 characters)
- ✅ Date formatting (HL7, ISO, display formats)
- ✅ Missing value handling (all 3 strategies)
- ✅ OID validation and insertion
- ✅ Nested placeholder replacement
- ✅ Whitespace preservation
- ✅ Error handling with clear messages
- ✅ Edge cases: empty template, empty values, None values
- ✅ Performance: batch processing simulation

**Integration Test:**

```python
# tests/integration/test_template_workflow.py

def test_complete_template_workflow():
    # Arrange
    loader = TemplateLoader()
    personalizer = TemplatePersonalizer()
    template = loader.load_from_file(Path("tests/fixtures/test_ccd_template.xml"))
    
    values = {
        "patient_id": "PAT-12345",
        "patient_id_oid": "1.2.3.4.5",
        "first_name": "John",
        "last_name": "Doe",
        "dob": date(1980, 1, 15),
        "gender": "M"
    }
    
    # Act
    result = personalizer.personalize(template, values)
    
    # Assert
    assert "PAT-12345" in result
    assert "19800115" in result  # HL7 formatted date
    validate_xml(result)  # Should be well-formed XML
```

### Implementation Guidelines

**TemplatePersonalizer Class Structure:**

```python
import re
from datetime import date, datetime
from enum import Enum
from html import escape as html_escape
from typing import Any, Optional
import logging

logger = logging.getLogger(__name__)

class MissingValueStrategy(Enum):
    """Strategy for handling missing placeholder values."""
    ERROR = "error"           # Raise exception
    USE_DEFAULT = "default"   # Use default value map
    USE_EMPTY = "empty"       # Use empty string

class TemplatePersonalizer:
    """Personalizes XML templates by replacing placeholders with values."""
    
    # Class-level compiled regex for performance
    PLACEHOLDER_PATTERN = re.compile(r'{{(\w+)}}')
    
    def __init__(
        self,
        date_format: str = "HL7",
        missing_value_strategy: MissingValueStrategy = MissingValueStrategy.ERROR,
        default_value_map: Optional[dict[str, str]] = None,
        max_nesting_depth: int = 3
    ):
        """Initialize template personalizer.
        
        Args:
            date_format: Date format to use (HL7, ISO, or custom strftime)
            missing_value_strategy: How to handle missing values
            default_value_map: Default values for missing fields
            max_nesting_depth: Maximum nesting depth for nested placeholders
        """
        self.date_format = date_format
        self.missing_value_strategy = missing_value_strategy
        self.default_value_map = default_value_map or {}
        self.max_nesting_depth = max_nesting_depth
        logger.debug(f"TemplatePersonalizer initialized with format={date_format}")
    
    def personalize(self, template: str, values: dict[str, Any]) -> str:
        """Personalize template by replacing placeholders.
        
        Args:
            template: XML template with {{field_name}} placeholders
            values: Dictionary of field values
            
        Returns:
            Personalized XML string
            
        Raises:
            MissingPlaceholderValueError: If required value missing
            MaxNestingDepthError: If nesting depth exceeded
        """
        logger.info(f"Personalizing template ({len(template)} chars, {len(values)} values)")
        
        # Extract placeholders from template
        placeholders = self._extract_placeholders(template)
        logger.debug(f"Found {len(placeholders)} unique placeholders")
        
        # Check for missing values
        missing = placeholders - values.keys()
        if missing:
            self._handle_missing_values(missing, values)
        
        # Perform replacement with nesting support
        result = self._replace_placeholders(template, values, depth=0)
        
        logger.info("Template personalization complete")
        return result
    
    def _replace_placeholders(
        self, 
        text: str, 
        values: dict[str, Any], 
        depth: int
    ) -> str:
        """Replace placeholders with values, supporting nesting."""
        if depth > self.max_nesting_depth:
            raise MaxNestingDepthError(
                f"Maximum nesting depth ({self.max_nesting_depth}) exceeded"
            )
        
        def replacer(match):
            field_name = match.group(1)
            value = values.get(field_name)
            
            # Format value based on type
            formatted_value = self._format_value(value, field_name)
            
            # Check if formatted value contains placeholders (nesting)
            if '{{' in formatted_value:
                return self._replace_placeholders(formatted_value, values, depth + 1)
            
            return formatted_value
        
        return self.PLACEHOLDER_PATTERN.sub(replacer, text)
    
    def _format_value(self, value: Any, field_name: str) -> str:
        """Format value based on type."""
        if value is None:
            return ""
        
        # Date formatting
        if isinstance(value, (date, datetime)):
            return self._format_date(value)
        
        # String values: XML escape
        value_str = str(value)
        return escape_xml_value(value_str)
    
    def _format_date(self, value: date | datetime) -> str:
        """Format date/datetime based on configured format."""
        if self.date_format == "HL7":
            if isinstance(value, datetime):
                return value.strftime("%Y%m%d%H%M%S")
            return value.strftime("%Y%m%d")
        elif self.date_format == "ISO":
            return value.isoformat()
        else:
            # Custom strftime format
            return value.strftime(self.date_format)
    
    # ... more methods


def escape_xml_value(value: str) -> str:
    """Escape XML special characters in value.
    
    Args:
        value: String value to escape
        
    Returns:
        XML-safe string with special characters escaped
    """
    # html.escape handles &, <, >, but we also need quotes
    escaped = html_escape(value, quote=True)
    # html.escape uses &quot; for quotes by default when quote=True
    # Also escape single quotes for XML attributes
    escaped = escaped.replace("'", "&apos;")
    return escaped


def format_date_value(value: date | datetime, format_type: str = "HL7") -> str:
    """Format date value for XML insertion.
    
    Args:
        value: Date or datetime to format
        format_type: Format type (HL7, ISO, or custom strftime)
        
    Returns:
        Formatted date string
    """
    if format_type == "HL7":
        if isinstance(value, datetime):
            return value.strftime("%Y%m%d%H%M%S")
        return value.strftime("%Y%m%d")
    elif format_type == "ISO":
        return value.isoformat()
    else:
        return value.strftime(format_type)
```

**Exception Definitions:**

Add to `src/ihe_test_util/utils/exceptions.py`:

```python
class MissingPlaceholderValueError(TemplateError):
    """Raised when required placeholder value is missing."""
    pass

class MaxNestingDepthError(TemplateError):
    """Raised when nested placeholders exceed maximum depth."""
    pass

class InvalidOIDFormatError(TemplateError):
    """Raised when OID format is invalid (strict mode only)."""
    pass
```

### Performance Considerations

**Batch Processing Optimization:**

- Compile regex pattern once at class level (not per personalization)
- Use string replacement, not XML parsing (faster)
- Target performance: <100ms per personalization
- For 100 patients: <10 seconds total

**Performance Test:**

```python
def test_batch_personalization_performance(benchmark):
    personalizer = TemplatePersonalizer()
    template = "..." # Typical CCD template
    values = {...}   # Typical patient values
    
    # Should complete in <100ms
    result = benchmark(personalizer.personalize, template, values)
    assert len(result) > len(template)  # Placeholders replaced
```

### Integration Points

**Upstream Dependencies (Story 3.1):**
- `TemplateLoader.load_from_file()` - Loads template before personalization
- `extract_placeholders()` - Can verify all needed values present
- `validate_xml()` - Validate personalized result is well-formed

**Downstream Usage (Story 3.3):**
- Story 3.3 (CCD Personalization) will use both TemplateLoader and TemplatePersonalizer
- Workflow: Load template → Extract patient from DataFrame → Personalize

**No Circular Dependencies** - Personalizer is independent, only depends on validators utility functions.

## Dev Agent Record

### File List
- **Created:**
  - `src/ihe_test_util/template_engine/personalizer.py` - TemplatePersonalizer class with full string replacement engine
  - `tests/unit/test_personalizer.py` - Comprehensive unit tests (47 tests)
  - `tests/integration/test_template_workflow.py` - Integration tests for loader + personalizer workflow (9 tests)

- **Modified:**
  - `src/ihe_test_util/template_engine/__init__.py` - Added exports for TemplatePersonalizer, MissingValueStrategy, escape_xml_value, format_date_value, validate_oid
  - `src/ihe_test_util/utils/exceptions.py` - Added MissingPlaceholderValueError, MaxNestingDepthError, InvalidOIDFormatError

### Test Results
**Unit Tests:** 47/47 PASSED ✅
- Coverage: personalizer.py 97%
- All AC requirements tested
- Performance test confirms <100ms per personalization

**Integration Tests:** 9/9 PASSED ✅
- Template loading + personalization workflow
- XML validation after personalization
- Batch processing (10 patients)
- Multiple missing value strategies
- XML special character escaping
- Date format variations

### Completion Notes
- All acceptance criteria met
- 100% test pass rate (56/56 total tests)
- Performance target achieved (<100ms per personalization)
- Full integration with Story 3.1 TemplateLoader
- All coding standards followed (type hints, docstrings, logging, exception handling)

## QA Results

### Review Date: 2025-11-09

### Reviewed By: Quinn (Test Architect)

### Test Execution Results

**Unit Tests:**
- Command: `python -m pytest tests/unit/test_personalizer.py -v`
- Result: 47/47 PASSED ✅
- Coverage: personalizer.py 97%

**Integration Tests:**
- Command: `python -m pytest tests/integration/test_template_workflow.py -v`
- Result: 9/9 PASSED ✅
- Coverage: loader.py 54%, personalizer.py 75% (integration context)

**Total Test Results: 56/56 PASSED (100% pass rate)**

### Code Quality Assessment

Exceptional implementation quality that matches Story 3.1's standards. The string replacement engine demonstrates professional software engineering with:

- **Clean Architecture:** Well-structured class design with clear separation between core personalization logic, value formatting, and error handling
- **Performance Optimization:** Class-level regex compilation for batch efficiency, target <100ms per personalization achieved
- **Comprehensive Error Handling:** Three missing value strategies (ERROR, USE_DEFAULT, USE_EMPTY) with actionable error messages
- **Type Safety:** Complete type hints on all signatures including use of union types (date | datetime)
- **Professional Documentation:** Google-style docstrings with examples throughout

### Refactoring Performed

No refactoring required. Implementation is production-ready as submitted.

### Compliance Check

- Coding Standards: ✅ All 7 critical rules followed rigorously
  - RULE 1: Logging module used (no print statements)
  - RULE 5: Actionable error messages with context
  - RULE 6: Specific exception catching (no bare except)
  - RULE 7: Complete type hints on all signatures
- Project Structure: ✅ Files correctly placed in template_engine module
- Testing Strategy: ✅ AAA pattern, comprehensive coverage, performance tests included
- All ACs Met: ✅ All 10 acceptance criteria validated by tests

### Requirements Traceability (Given-When-Then)

**AC 1: Replacement engine accepts template and dictionary**
- Given: A template string with `{{field_name}}` placeholders and a values dictionary
- When: `personalizer.personalize(template, values)` is called
- Then: All placeholders are replaced with corresponding dictionary values
- Tests: `test_personalize_simple_placeholders`, `test_personalize_all_placeholders_replaced`

**AC 2: All placeholder instances replaced**
- Given: Multiple instances of the same placeholder in template
- When: Personalization is performed
- Then: All instances are replaced consistently
- Tests: `test_personalize_all_placeholders_replaced`, `test_personalize_multiple_occurrences_same_placeholder`

**AC 3: Missing values trigger clear error or use configurable default**
- Given: Placeholder in template without corresponding value
- When: Personalization is performed with ERROR strategy
- Then: `MissingPlaceholderValueError` raised with list of missing fields
- Tests: `test_personalize_missing_value_error_strategy`, `test_personalize_missing_value_use_empty_strategy`, `test_personalize_missing_value_use_default_strategy`

**AC 4: Special character escaping for XML**
- Given: Values containing &, <, >, ", ' characters
- When: Values are inserted into template
- Then: Characters are escaped (&amp;, &lt;, &gt;, &quot;, &apos;)
- Tests: All 8 tests in `TestXMLEscaping` class

**AC 5: Date formatting applied automatically**
- Given: date or datetime values in dictionary
- When: Personalization is performed
- Then: Dates formatted per configured format (HL7, ISO, custom)
- Tests: All 6 tests in `TestDateFormatting` class

**AC 6: OID values properly inserted**
- Given: Field name ending in `_oid` with OID value
- When: Personalization is performed
- Then: OID validated, inserted without XML escaping, warning logged if invalid
- Tests: All 10 tests in `TestOIDValidation` class

**AC 7: Whitespace and indentation preserved**
- Given: Template with specific indentation and newlines
- When: Placeholders are replaced
- Then: Original whitespace structure maintained
- Tests: `test_personalize_preserves_whitespace`

**AC 8: Support for nested placeholders**
- Given: Placeholder value containing another placeholder
- When: Personalization is performed
- Then: Inner placeholders resolved recursively up to max depth
- Tests: `test_personalize_nested_placeholders`, `test_personalize_max_nesting_depth_exceeded`

**AC 9: Efficient for batch processing (100+ patients)**
- Given: 100 patient records to personalize
- When: Batch personalization is performed
- Then: Completes in <10 seconds (<100ms per personalization)
- Tests: `test_batch_personalization_performance` (verified: passes in 4.09s)

**AC 10: Comprehensive unit tests**
- Given: Complete test suite
- When: Tests are executed
- Then: 47 unit tests + 9 integration tests all pass with 97% coverage
- Evidence: 56/56 tests passed, personalizer.py 97% coverage

### Security Review

**Status: PASS**

- XML injection prevented through comprehensive escaping of all 5 special characters
- OID validation prevents malformed identifiers (permissive mode logs warning)
- No external file I/O or network calls (pure string processing)
- No use of eval(), exec(), or dynamic code execution
- Input validation for all value types (date, string, numeric)

### Performance Considerations

**Status: PASS**

- Regex pattern compiled once at class level (shared across instances)
- String replacement used instead of XML parsing (10x+ faster)
- Target achieved: <100ms per personalization
- Batch test: 100 patients in 4.09s (40ms average per personalization)
- Memory efficient: O(n) where n is template size
- No unnecessary object creation in hot path

### Files Modified During Review

None. No modifications were required during QA review.

### Gate Status

Gate: PASS → docs/qa/gates/3.2-string-replacement-engine.yml

### Recommended Status

✅ **Ready for Done**

This story represents exceptional implementation quality that should serve as a reference for future template engine work. All acceptance criteria met, comprehensive test coverage, production-ready code with no concerns.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-09 | 1.0 | Initial story creation for Epic 3 | Scrum Master (Bob) |
| 2025-11-09 | 1.1 | Story validated and approved for implementation | Product Owner (Sarah) |
| 2025-11-09 | 2.0 | Implementation complete - All tests passing | Developer (James) |
| 2025-11-09 | 2.1 | QA Review complete - Gate PASS | Quinn (Test Architect) |
